# LLM input file


===== ./index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Asynchronous Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            dark: { bg: '#1a202c', text: '#e2e8f0' },
          },
        },
      },
    };
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js"></script>
</head>
<body class="font-inter bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-50">
  <div id="app" class="flex h-screen overflow-hidden">
    <aside id="control-panel" class="w-80 max-w-full shrink-0 overflow-y-auto bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4 space-y-6 fixed inset-y-0 left-0 z-20 transform transition-transform duration-300 md:static md:transform-none hidden md:block">
      <header class="space-y-1">
        <h2 class="flex items-center text-lg font-semibold gap-1">
          <span class="material-icons-outlined text-base">tune</span>
          Controls
        </h2>
        <p id="status" class="text-sm text-gray-500 dark:text-gray-400">Loading Pyodide…</p>
        <label class="relative inline-flex items-center cursor-pointer">
          <input id="darkModeToggle" type="checkbox" class="sr-only peer">
          <div class="w-10 h-5 bg-gray-300 rounded-full peer-checked:bg-blue-600
                      after:content-[''] after:absolute after:top-0.5 after:left-1
                      after:w-4 after:h-4 after:bg-white after:rounded-full
                      after:transition-all peer-checked:after:translate-x-5"></div>
          <span class="ml-2 text-sm">Dark Mode</span>
        </label>
      </header>
      <section class="space-y-4">
        <label class="flex flex-col gap-1">
          <span class="text-sm font-medium">Algorithm</span>
          <select id="algorithm"
                  class="rounded border-gray-300 bg-white text-gray-900
                         dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100
                         text-sm p-1.5 focus:ring-blue-500 focus:border-blue-500">
            <option value="Gathering" selected>Center of Gravity</option>
            <option value="SEC">Smallest Enclosing Circle</option>
          </select>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Robots
          <input id="num_robots" type="range" min="1" max="50" value="5" class="flex-1 accent-blue-600">
          <output id="num_robots_val">5</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Speed
          <input id="robot_speed" type="range" min="0.1" max="10" step="0.1" value="1.0" class="flex-1 accent-blue-600">
          <output id="robot_speed_val">1.0</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Visibility
          <input id="visibility_radius" type="range" min="10" max="1000" step="10" value="150" class="flex-1 accent-blue-600">
          <output id="visibility_radius_val">150</output>
          <label class="relative inline-flex items-center cursor-pointer">
            <input id="infinite_visibility" type="checkbox" class="sr-only peer">
            <div class="w-10 h-5 bg-gray-300 rounded-full peer-checked:bg-blue-600
                        after:content-[''] after:absolute after:top-0.5 after:left-1
                        after:w-4 after:h-4 after:bg-white after:rounded-full
                        after:transition-all peer-checked:after:translate-x-5"></div>
            <span class="ml-2 text-sm">Inf</span>
          </label>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Faulty
          <input id="num_faults" type="range" min="0" max="10" step="1" value="0" class="flex-1 accent-blue-600">
          <output id="num_faults_val">0</output>
        </label>

        <label class="inline-flex items-center gap-3 text-sm font-medium">
          <input id="rigid_movement" type="checkbox" checked
                 class="h-4 w-4 text-blue-600 border-gray-300 rounded dark:border-gray-600 dark:bg-gray-700">
          Rigid movement
        </label>

        <h3 class="pt-2 font-semibold">Environment</h3>

        <label class="flex items-center gap-2 text-sm font-medium">
          World W
          <input id="width_bound" type="range" min="50" max="1000" step="10" value="600" class="flex-1 accent-blue-600">
          <output id="width_bound_val">600</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          World H
          <input id="height_bound" type="range" min="50" max="1000" step="10" value="600" class="flex-1 accent-blue-600">
          <output id="height_bound_val">600</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          λ (rate)
          <input id="lambda_rate" type="range" min="0.1" max="20" step="0.1" value="5.0" class="flex-1 accent-blue-600">
          <output id="lambda_rate_val">5.0</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Samples
          <input id="sampling_rate" type="range" min="0.05" max="1" step="0.05" value="0.1" class="flex-1 accent-blue-600">
          <output id="sampling_rate_val">0.1</output>
        </label>

        <label class="flex items-center gap-2 text-sm font-medium">
          Precision 1e-
          <input id="threshold_precision" type="range" min="2" max="10" step="1" value="5" class="flex-1 accent-blue-600">
          <output id="threshold_precision_val">5</output>
        </label>

        <label class="flex flex-col gap-1">
          <span class="text-sm font-medium">Random seed</span>
          <input id="random_seed" type="number" value="12345"
                 class="rounded border-gray-300 p-1.5 text-sm w-full dark:bg-gray-800 dark:border-gray-600 dark:text-gray-100">
        </label>

        <div class="flex gap-3 pt-2">
          <button id="start_button" disabled
                  class="px-4 py-1.5 rounded bg-blue-600 text-white font-medium
                         dark:bg-blue-500 dark:text-gray-100 disabled:opacity-50">
            Start
          </button>
          <button id="stop_button" disabled
                  class="px-4 py-1.5 rounded border border-gray-300 dark:border-gray-600
                         text-gray-800 dark:text-gray-100 disabled:opacity-50">
            Stop
          </button>
        </div>

        <div id="legend" class="space-y-1 text-sm text-gray-600 dark:text-gray-300"></div>
        <p id="sim_time"    class="text-sm text-gray-600 dark:text-gray-300"></p>
        <p id="sim_message" class="text-sm font-medium text-gray-700 dark:text-gray-200"></p>
      </section>
    </aside>
    <main id="visualization" class="flex-1 relative bg-gray-100 dark:bg-gray-800">
      <button id="toggle-controls" class="md:hidden fixed top-4 left-4 z-30 w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center shadow">
        <span class="material-icons-outlined">menu</span>
      </button>
      <div class="overflow-auto w-full h-full">
        <canvas id="canvas" width="800" height="800" class="block border border-gray-300 dark:border-gray-600"></canvas>
      </div>
      <div class="absolute top-4 right-4 flex flex-col gap-2">
        <button id="zoom_in_btn"
                class="w-10 h-10 rounded-full bg-white shadow border text-lg font-semibold
                       dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">＋</button>
        <button id="zoom_out_btn"
                class="w-10 h-10 rounded-full bg-white shadow border text-lg font-semibold
                       dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">－</button>
      </div>
    </main>
  </div>
  <script defer src="main.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const saved = localStorage.getItem('darkMode');
      const html  = document.documentElement;
      const dark  = saved === 'true';
      html.classList.toggle('dark', dark);
      const toggle = document.getElementById('darkModeToggle');
      toggle.checked = dark;
      toggle.addEventListener('click', () => {
        const nowDark = !html.classList.contains('dark');
        html.classList.toggle('dark', nowDark);
        localStorage.setItem('darkMode', nowDark.toString());
      });

      const controlPanel = document.getElementById('control-panel');
      const toggleButton = document.getElementById('toggle-controls');
      toggleButton.addEventListener('click', () => {
        controlPanel.classList.toggle('hidden');
      });
    });
  </script>
</body>
</html>
===== ./main.js =====
/* ================================================================
 *  main.js  —  robots coloured by state, no number labels
 * ================================================================ */

/* -------- DOM refs ------------------------------------------------ */
const statusDiv     = document.getElementById("status");
const startBtn      = document.getElementById("start_button");
const stopBtn       = document.getElementById("stop_button");
const zoomInBtn     = document.getElementById("zoom_in_btn");
const zoomOutBtn    = document.getElementById("zoom_out_btn");

const canvas        = document.getElementById("canvas");
const ctx           = canvas.getContext("2d");

const simTimeDiv    = document.getElementById("sim_time");
const simMsgDiv     = document.getElementById("sim_message");

/* sliders / fields (unchanged from previous version) -------------- */
const algorithmSelect = document.getElementById("algorithm");
const numRobotsSlider = document.getElementById("num_robots");
const numRobotsVal    = document.getElementById("num_robots_val");
const robotSpeedSlider = document.getElementById("robot_speed");
const robotSpeedVal    = document.getElementById("robot_speed_val");

const visibilitySlider  = document.getElementById("visibility_radius");
const visibilityVal     = document.getElementById("visibility_radius_val");
const infiniteVisChk    = document.getElementById("infinite_visibility");

const numFaultsSlider   = document.getElementById("num_faults");
const numFaultsVal      = document.getElementById("num_faults_val");
const rigidChk          = document.getElementById("rigid_movement");

const widthSlider       = document.getElementById("width_bound");
const widthVal          = document.getElementById("width_bound_val");
const heightSlider      = document.getElementById("height_bound");
const heightVal         = document.getElementById("height_bound_val");

const lambdaSlider      = document.getElementById("lambda_rate");
const lambdaVal         = document.getElementById("lambda_rate_val");
const sampleSlider      = document.getElementById("sampling_rate");
const sampleVal         = document.getElementById("sampling_rate_val");

const precisionSlider   = document.getElementById("threshold_precision");
const precisionVal      = document.getElementById("threshold_precision_val");

const seedInput         = document.getElementById("random_seed");

/* -------- Pyodide / sim state ------------------------------------ */
let pyodide      = null;
let pythonRunner = null;
let simRunning   = false;
let animFrameId  = null;

/* -------- canvas / world config ---------------------------------- */
const ROBOT_R = 5;
let scale   = 1;
let offsetX = 0, offsetY = 0;

const ZOOM_STEP = 1.15;
const MIN_SCALE = 0.05;
const MAX_SCALE = 50;

let lastRobotsFrame = [];

/* -------- helpers ------------------------------------------------ */
const updStatus = (msg) => (statusDiv.textContent = msg);
function updMsg(msg) {
  simMsgDiv.textContent = msg;
  simMsgDiv.style.color       = msg.toLowerCase().includes("error") ? "red" : "";
  simMsgDiv.style.fontWeight  = msg.toLowerCase().includes("error") ? "600" : "";
}
const updSlider = (sl, out) => (out.textContent = sl.value);

/* -------- canvas auto-size --------------------------------------- */
function resizeCanvas() {
  const vis = document.getElementById("visualization");
  if (!vis) return;

  const { width, height } = vis.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.floor(width  * dpr);
  canvas.height = Math.floor(height * dpr);
  canvas.style.width  = `${width}px`;
  canvas.style.height = `${height}px`;

  offsetX = width / 2;
  offsetY = height / 2;

  const w = +widthSlider.value, h = +heightSlider.value;
  scale = Math.min(width / w, height / h) * 0.9;

  if (lastRobotsFrame.length) drawSimulation(lastRobotsFrame);
}

/* -------- zoom buttons ------------------------------------------- */
function applyZoom(factor) {
  scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * factor));
  if (lastRobotsFrame.length) drawSimulation(lastRobotsFrame);
}
zoomInBtn .addEventListener("click", () => applyZoom(ZOOM_STEP));
zoomOutBtn.addEventListener("click", () => applyZoom(1 / ZOOM_STEP));

/* -------- Pyodide bootstrap -------------------------------------- */
async function loadPyodideAndPackages() {
  updStatus("Loading Pyodide…");
  try {
    pyodide = await loadPyodide();
    await pyodide.loadPackage(["numpy", "micropip"]);
    const files = ["robot.py", "scheduler.py", "run.py"];
    for (const f of files) {
      const code = await (await fetch(`./${f}`)).text();
      pyodide.FS.writeFile(f, code);
    }
    await pyodide.runPythonAsync("import run as simulation_runner");
    pythonRunner = pyodide.globals.get("simulation_runner");

    updStatus("Ready. Click Start.");
    startBtn.disabled = false;
  } catch (err) {
    updStatus(`Pyodide init error: ${err.message}`);
  }
}

/* -------- simulation control ------------------------------------- */
function params() {
  return {
    algorithm          : algorithmSelect.value,
    num_of_robots      : +numRobotsSlider.value,
    robot_speeds       : +robotSpeedSlider.value,
    visibility_radius  : infiniteVisChk.checked ? null : +visibilitySlider.value,
    num_of_faults      : +numFaultsSlider.value,
    rigid_movement     : rigidChk.checked,
    width_bound        : +widthSlider.value,
    height_bound       : +heightSlider.value,
    lambda_rate        : +lambdaSlider.value,
    sampling_rate      : +sampleSlider.value,
    threshold_precision: +precisionSlider.value,
    random_seed        : +seedInput.value,
    initial_positions  : []
  };
}

async function startSimulation() {
  if (simRunning || !pythonRunner) return;
  startBtn.disabled = true; stopBtn.disabled = false; simRunning = true; updMsg("");
  try {
    const setup = JSON.parse(await pythonRunner.setup_simulation(JSON.stringify(params())));
    if (setup.status === "error") throw new Error(setup.message);
    simTimeDiv.textContent = `Time: ${setup.time.toFixed(2)}`;
    drawSimulation(setup.robots); lastRobotsFrame = setup.robots;
    updStatus("Simulation running…");
    animFrameId = requestAnimationFrame(simStep);
  } catch (err) {
    updStatus("Start error."); updMsg(`Error: ${err.message}`);
    startBtn.disabled = false; stopBtn.disabled = true; simRunning = false;
  }
}

function stopSimulation() {
  if (!simRunning) return;
  simRunning = false; cancelAnimationFrame(animFrameId);
  try { updMsg(JSON.parse(pythonRunner.stop_simulation()).message); } catch {}
  updStatus("Simulation stopped."); startBtn.disabled = false; stopBtn.disabled = true;
}

/* ============================ main.js ============================ */
/* --- replace the whole simStep() with this version -------------- */
async function simStep() {
    if (!simRunning) return;
    try {
      const step = JSON.parse(await pythonRunner.run_simulation_step());
  
      /* update wall-clock time + UI msg */
      simTimeDiv.textContent = `Time: ${step.time.toFixed(2)}`;
      if (step.message) updMsg(step.message);
  
      /* redraw **only** on VISUALIZE (exit_code 99) or when simulation stops */
      const shouldRedraw = step.exit_code === 99 || step.status !== "running";
      if (shouldRedraw && step.robots) {
        drawSimulation(step.robots);
        lastRobotsFrame = step.robots;
      }
  
      /* stop loop if sim finished */
      if (step.status !== "running") {
        simRunning = false;
        updStatus(`Simulation ${step.status}.`);
        startBtn.disabled = false;
        stopBtn.disabled  = true;
        return;
      }
    } catch (err) {
      updStatus("Runtime error!");
      updMsg(`Error: ${err.message}`);
      simRunning = false;
      startBtn.disabled = false;
      stopBtn.disabled  = true;
    }
    if (simRunning) animFrameId = requestAnimationFrame(simStep);
  }
  

/* -------- drawing ------------------------------------------------ */
const STATE_COLORS = {
  CRASH      : "#555555",
  TERMINATED : "#a0a0a0",
  FROZEN     : "#ff9500",
  MOVE       : "#34c759",
  DEFAULT    : "#007aff"    // LOOK / WAIT / others
};
/* ---------- build legend (once) --------------------------------- */
function buildLegend() {
    const legendDiv = document.getElementById("legend");
    if (!legendDiv) return;
  
    const LABELS = {
      DEFAULT   : "Active (LOOK / WAIT)",
      MOVE      : "Moving",
      FROZEN    : "Frozen",
      TERMINATED: "Terminated",
      CRASH     : "Crashed"
    };
  
    Object.entries(STATE_COLORS).forEach(([key, hex]) => {
      if (!LABELS[key]) return;                // skip unknown keys
      const item   = document.createElement("div");
      item.className = "legend-item";
      item.innerHTML =
        `<span class="inline-block mr-2 rounded-sm"
          style="background:${hex};width:1rem;height:1rem;"></span>${LABELS[key]}`;
      legendDiv.appendChild(item);
    });
  }
  
function colorForRobot(r) {
  if (r.crashed)       return STATE_COLORS.CRASH;
  if (r.terminated)    return STATE_COLORS.TERMINATED;
  if (r.frozen)        return STATE_COLORS.FROZEN;
  if (r.state === "MOVE") return STATE_COLORS.MOVE;
  return STATE_COLORS.DEFAULT;
}

function transform(x, y) { return { x: offsetX + x * scale, y: offsetY - y * scale }; }

function drawSimulation(robots) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  robots.forEach((r) => {
    const p = transform(r.x, r.y);
    const c = colorForRobot(r);

    /* body */
    ctx.fillStyle = c; ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(p.x, p.y, ROBOT_R, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

    /* target line */
    if (r.state === "MOVE" && r.target_x != null) {
      const t = transform(r.target_x, r.target_y);
      ctx.setLineDash([2, 3]); ctx.strokeStyle = c; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(t.x, t.y); ctx.stroke(); ctx.setLineDash([]);
    }

    /* SEC (SEC algorithm only) */
    if (algorithmSelect.value === "SEC" && r.sec) {
      const sc = transform(r.sec.center_x, r.sec.center_y);
      ctx.strokeStyle = "rgba(255,165,0,0.6)"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(sc.x, sc.y, r.sec.radius * scale, 0, Math.PI * 2); ctx.stroke();
    }

    /* visibility */
    if (r.visibility_radius && !r.crashed && !r.terminated) {
      ctx.strokeStyle = "rgba(100,100,200,.25)"; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(p.x, p.y, r.visibility_radius * scale, 0, Math.PI * 2); ctx.stroke();
    }
  });
}

/* -------- listeners & init -------------------------------------- */
startBtn.addEventListener("click", startSimulation);
stopBtn .addEventListener("click", stopSimulation);
window.addEventListener("resize", resizeCanvas);

[
  [numRobotsSlider, numRobotsVal], [robotSpeedSlider, robotSpeedVal],
  [visibilitySlider, visibilityVal], [numFaultsSlider, numFaultsVal],
  [widthSlider, widthVal], [heightSlider, heightVal],
  [lambdaSlider, lambdaVal], [sampleSlider, sampleVal],
  [precisionSlider, precisionVal]
].forEach(([sl, out]) => {
  updSlider(sl, out); sl.addEventListener("input", () => updSlider(sl, out));
});

infiniteVisChk.addEventListener("change", () => {
  visibilitySlider.disabled = infiniteVisChk.checked;
  visibilityVal.textContent = infiniteVisChk.checked ? "Inf" : visibilitySlider.value;
});

/* First-time layout */
buildLegend(); 
resizeCanvas(); 
drawSimulation([]);
loadPyodideAndPackages();
console.log("main.js loaded.");

===== ./robot.py =====
import math
from typing import NamedTuple, Callable, List, Dict, Tuple, Union # Keep Union for type hints if needed

class RobotState:
    LOOK = "LOOK"
    MOVE = "MOVE"
    WAIT = "WAIT"
    TERMINATED = "TERMINATED"
    CRASH = "CRASH"

    @staticmethod
    def next_state(current_state: str) -> str: # Add type hints here too
        if current_state == RobotState.CRASH:
            return RobotState.CRASH
        elif current_state == RobotState.LOOK:
            return RobotState.MOVE
        elif current_state == RobotState.MOVE:
            return RobotState.WAIT
        elif current_state == RobotState.WAIT:
            return RobotState.LOOK
        return current_state # Default fallback

class SchedulerType:
    ASYNC = "Async"

class DistributionType:
    EXPONENTIAL = "Exponential"

class Algorithm:
    GATHERING = "Gathering"
    SEC = "SEC"


Time = float
Id = int

class Coordinates(NamedTuple):
    x: float
    y: float
    def __str__(self):
        return f"({float(self.x):.4f}, {float(self.y):.4f})"

class Circle(NamedTuple):
    center: Coordinates
    radius: float
    def __str__(self):
        return f"Center: {self.center} ; radius: {float(self.radius):.4f}"

class SnapshotDetails(NamedTuple):
    pos: Coordinates
    state: str
    frozen: bool
    terminated: bool
    multiplicity: Union[int, None] # Use Union for type hint clarity

class Event(NamedTuple):
    time: Time # Use type alias
    id: Id    # Use type alias
    state: str

class Orientation(NamedTuple): # Keep definition even if unused for now
    translation: float
    rotation: float
    reflection: float

# --- Robot Class Definition (Mostly unchanged logic) ---

# Simple logging replacement
class SimpleLogger:
    def info(self, msg):
        print(f"INFO: {msg}")
    def warning(self, msg):
        print(f"WARN: {msg}")
    def error(self, msg):
        print(f"ERROR: {msg}")

class Robot:
    _logger = SimpleLogger()
    _generator = None # Will be set by scheduler

    def __init__(
        self,
        id: Id, # Use type alias
        coordinates: Coordinates,
        algorithm: str, # e.g., Algorithm.GATHERING
        speed: float = 1.0,
        color: Union[str, None] = None, # Use Union
        visibility_radius: Union[float, None] = None, # Use Union
        # orientation: Union[Orientation, None] = None, # Keep if needed later
        # obstructed_visibility: bool = False, # Keep if needed later
        multiplicity_detection: bool = False,
        rigid_movement: bool = False,
        threshold_precision: float = 5,
    ):
        self.speed = speed
        self.color = color
        # Ensure visibility_radius is float or inf
        self.visibility_radius = float(visibility_radius) if visibility_radius is not None else float('inf')
        # self.obstructed_visibility = obstructed_visibility
        self.multiplicity_detection = multiplicity_detection
        self.rigid_movement = rigid_movement
        # self.orientation = orientation
        self.start_time: Union[Time, None] = None # Use type alias and Union
        self.end_time: Union[Time, None] = None   # Use type alias and Union
        self.state: str = RobotState.WAIT # Use constant from this file
        self.start_position: Coordinates = coordinates
        self.calculated_position: Union[Coordinates, None] = None
        self.number_of_activations: int = 0
        self.travelled_distance: float = 0.0
        self.snapshot: Union[Dict[Id, SnapshotDetails], None] = None # Use Dict, Id
        self.coordinates: Coordinates = coordinates
        self.id: Id = id # Use type alias
        self.threshold_precision: float = threshold_precision
        self.frozen: bool = False
        self.terminated: bool = False
        self.sec: Union[Circle, None] = None # Stores the calculated SEC

        # Assign algorithm type based on the input string constant
        if algorithm == Algorithm.GATHERING:
             self.algorithm_type = Algorithm.GATHERING
        elif algorithm == Algorithm.SEC:
             self.algorithm_type = Algorithm.SEC
        else:
             raise ValueError(f"Unknown algorithm: {algorithm}")


    def set_faulty(self, faulty: bool) -> None:
        if faulty:
            self.state = RobotState.CRASH

    def look(
        self,
        snapshot: Dict[Id, SnapshotDetails], # Use Dict, Id
        time: Time,                         # Use Time
    ) -> None:
        if self.state == RobotState.CRASH: return

        self.state = RobotState.LOOK

        self.snapshot = {}
        for key, value in snapshot.items():
            if self.visibility_radius == float('inf') or self._robot_is_visible(value.pos):
                transformed_pos = self._convert_coordinate(value.pos)
                # Make sure SnapshotDetails is used correctly
                self.snapshot[key] = SnapshotDetails(
                    transformed_pos,
                    value.state,
                    value.frozen,
                    value.terminated,
                    value.multiplicity,
                )

        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} LOOK    -- Snapshot {self.prettify_snapshot(self.snapshot)}"
        )

        active_visible_robots = [r for r_id, r in self.snapshot.items() if not r.terminated and r.state != RobotState.CRASH]

        if len(active_visible_robots) <= 1 and self.id in self.snapshot:
            self.frozen = True
            self.terminated = True
            Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} TERMINATED (only self visible)")
            self.wait(time)
            return

        algo, algo_terminal = self._select_algorithm()
        # Type hint for algo: Callable[[], Tuple[Coordinates, List[any]]]
        # Type hint for algo_terminal: Callable[[Coordinates, List[any]], bool]
        self.calculated_position = self._compute(algo, algo_terminal, time)
        pos_str = (
            f"({self.calculated_position.x:.4f}, {self.calculated_position.y:.4f})" # Access .x, .y
            if self.calculated_position
            else "None"
        )
        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} COMPUTE -- Computed Pos: {pos_str}"
        )

        if self.terminated:
             Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} TERMINATED (condition met in compute)")
             self.wait(time)
             return

        if self.calculated_position is None or \
           math.dist(self.calculated_position, self.coordinates) < 10**-self.threshold_precision:
            self.frozen = True
            Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} FROZEN (target reached or no movement)")
            self.wait(time)
        else:
            self.frozen = False

    def _compute(
        self,
        algo: Callable[[], Tuple[Coordinates, List[any]]],
        check_terminal: Callable[[Coordinates, List[any]], bool],
        time: Time
    ) -> Union[Coordinates, None]:
        try:
            coord, extra_args = algo()

            if check_terminal is None:
                Robot._logger.error("Algorithm termination function not passed in")
                return self.coordinates

            if check_terminal(coord, extra_args):
                Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} Termination condition met during compute.")
                self.terminated = True
                return coord # Return calculated coord, but flag is set

            else:
                 return coord

        except Exception as e:
            Robot._logger.error(f"[{time:.2f}] {{R{self.id}}} Error during _compute: {e}")
            self.frozen = True
            return self.coordinates


    def move(self, start_time: Time) -> None:
        if self.state == RobotState.CRASH or self.terminated or self.frozen:
             Robot._logger.info(f"[{start_time:.2f}] {{R{self.id}}} Skipping MOVE (State: {self.state}, Term: {self.terminated}, Frozen: {self.frozen})")
             self.state = RobotState.WAIT # Ensure it goes back to WAIT if frozen/terminated/crashed tried to move
             return

        if self.calculated_position is None:
             Robot._logger.warning(f"[{start_time:.2f}] {{R{self.id}}} MOVE called with no calculated_position. Skipping move.")
             self.state = RobotState.WAIT
             return

        self.state = RobotState.MOVE
        Robot._logger.info(f"[{start_time:.2f}] {{R{self.id}}} MOVE -> {self.calculated_position}")
        self.start_time = start_time
        self.start_position = self.coordinates

    def wait(self, time: Time) -> None:
        final_pos = self.get_position(time)
        current_distance = 0.0
        if self.start_time is not None and self.state == RobotState.MOVE:
             # Make sure start_position is Coordinates type
             current_distance = math.dist(self.start_position, final_pos)
             self.travelled_distance += current_distance

        self.coordinates = final_pos

        self.start_time = None
        self.end_time = time
        self.state = RobotState.WAIT

        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} WAIT    -- Pos: {self.coordinates} Dist: {current_distance:.4f} Total: {self.travelled_distance:.4f} Frozen: {self.frozen} Term: {self.terminated}"
        )


    def get_position(self, time: Time) -> Coordinates:
        if self.state != RobotState.MOVE or self.start_time is None or self.calculated_position is None:
            return self.coordinates

        target_distance = math.dist(self.start_position, self.calculated_position)

        if target_distance < 1e-9:
            return self.calculated_position

        elapsed_time = time - self.start_time
        distance_covered = self.speed * elapsed_time

        if distance_covered >= target_distance - (10**-self.threshold_precision):
            return self.calculated_position
        else:
            factor = distance_covered / target_distance
            interpolated_coords = self._interpolate(
                self.start_position, self.calculated_position, factor
            )
            return interpolated_coords


    def _select_algorithm(self) -> Tuple[Callable, Callable]: # Return types are complex, using Tuple[Callable, Callable]
        if self.algorithm_type == Algorithm.GATHERING:
            return (self._midpoint, self._midpoint_terminal)
        elif self.algorithm_type == Algorithm.SEC:
            return (self._smallest_enclosing_circle, self._sec_terminal)
        else:
            raise ValueError(f"Invalid algorithm type: {self.algorithm_type}")

    def _interpolate(
        self, start: Coordinates, end: Coordinates, t: float
    ) -> Coordinates:
        t = max(0.0, min(1.0, t))
        # Ensure Coordinates constructor is used
        return Coordinates(
            start.x + t * (end.x - start.x), start.y + t * (end.y - start.y)
        )

    def _convert_coordinate(self, coord: Coordinates) -> Coordinates:
        return coord

    def _robot_is_visible(self, coord: Coordinates) -> bool:
        if self.visibility_radius == float('inf'):
             return True
        distance = math.dist(self.coordinates, coord)
        return distance <= self.visibility_radius


    def _midpoint(self) -> Tuple[Coordinates, List[any]]:
        if not self.snapshot:
             Robot._logger.warning(f"{{R{self.id}}} Midpoint calculation with empty snapshot. Staying put.")
             return (self.coordinates, [])

        x = y = 0
        num_visible = 0
        for _, value in self.snapshot.items():
            x += value.pos.x # Access pos.x
            y += value.pos.y # Access pos.y
            num_visible += 1

        if num_visible == 0:
             return (self.coordinates, [])

        x /= num_visible
        y /= num_visible

        return (Coordinates(x, y), []) # Construct Coordinates


    def _midpoint_terminal(self, coord: Coordinates, args: List[any] = None) -> bool:
        if not self.snapshot:
             return True

        for robot_id, details in self.snapshot.items():
            if details.state != RobotState.CRASH:
                 # Access details.pos
                if math.dist(details.pos, coord) > math.pow(10, -self.threshold_precision):
                    return False
        return True

    # --- SEC Algorithm Methods ---
    # Ensure Coordinates, Circle, SnapshotDetails, etc. are used correctly from this file's definitions
    # Make sure .x, .y are accessed correctly on Coordinates objects

    def _smallest_enclosing_circle(self) -> Tuple[Coordinates, List[Union[Circle, None]]]:
        visible_robots_details = {rid: r for rid, r in self.snapshot.items() if r.state != RobotState.CRASH}
        points_coords: List[Coordinates] = [r.pos for r in visible_robots_details.values()] # List of Coordinates

        num_robots = len(points_coords)
        destination: Union[Coordinates, None] = None
        calculated_sec: Union[Circle, None] = None

        try:
            if num_robots == 0:
                destination = self.coordinates
                calculated_sec = None
            elif num_robots == 1:
                destination = points_coords[0]
                calculated_sec = Circle(points_coords[0], 0) # Use Circle constructor
            elif num_robots == 2:
                a, b = points_coords[0], points_coords[1]
                calculated_sec = self._circle_from_two(a, b)
                destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
            elif num_robots == 3:
                potential_sec = None
                for i in range(num_robots):
                    for j in range(i + 1, num_robots):
                        a, b = points_coords[i], points_coords[j]
                        sec_candidate = self._circle_from_two(a, b)
                        if self._valid_circle(sec_candidate, points_coords):
                            potential_sec = sec_candidate
                            break
                    if potential_sec: break

                if not potential_sec:
                     a, b, c = points_coords[0], points_coords[1], points_coords[2]
                     if abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) < 1e-9:
                         max_dist_sq = -1
                         p1, p2 = a, b
                         pairs = [(a, b), (a, c), (b, c)]
                         for p_i, p_j in pairs:
                             d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                             if d_sq > max_dist_sq:
                                 max_dist_sq = d_sq
                                 p1, p2 = p_i, p_j
                         potential_sec = self._circle_from_two(p1, p2)
                     else:
                         potential_sec = self._circle_from_three(a, b, c)

                calculated_sec = potential_sec
                if calculated_sec:
                     destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
                else:
                     Robot._logger.warning(f"[{self.id}] Failed to calculate SEC for 3 points. Staying put.")
                     destination = self.coordinates
            else: # > 3 robots
                calculated_sec = self._sec_welzl_coords(points_coords)
                if calculated_sec:
                    destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
                else:
                     Robot._logger.warning(f"[{self.id}] Failed to calculate SEC via Welzl. Staying put.")
                     destination = self.coordinates

            self.sec = calculated_sec
            # Ensure destination is always Coordinates
            final_destination = destination if destination is not None else self.coordinates
            return (final_destination, [self.sec])

        except Exception as e:
            Robot._logger.error(f"[{self.id}] Error in _smallest_enclosing_circle: {e}")
            return (self.coordinates, [None])


    def _sec_terminal(self, _, args: List[Union[Circle, None]]) -> bool:
        if not args or args[0] is None:
            return False

        circle: Circle = args[0] # Now explicitly Circle type

        visible_robots_details = {rid: r for rid, r in self.snapshot.items() if r.state != RobotState.CRASH}

        if not visible_robots_details:
             return True

        for robot_id, details in visible_robots_details.items():
            # Pass details.pos (Coordinates) to is_point_on_circle
            if not self._is_point_on_circle(details.pos, circle):
                 return False
        return True


    def _sec_welzl_coords(self, points: List[Coordinates]) -> Union[Circle, None]:
        if not points: return None
        points_copy = points.copy()
        if Robot._generator is None:
             Robot._logger.error("Robot._generator not set for Welzl shuffle!")
             import random
             random.shuffle(points_copy)
        else:
            Robot._generator.shuffle(points_copy)
        return self._sec_welzl_recur_coords(points_copy, [], len(points_copy))


    def _sec_welzl_recur_coords(self, P: List[Coordinates], R: List[Coordinates], n: int) -> Circle:
        if n == 0 or len(R) == 3:
            return self._min_circle(R)

        idx = Robot._generator.integers(0, n) if n > 0 else 0
        p = P[idx]
        P[idx], P[n - 1] = P[n - 1], P[idx]

        c = self._sec_welzl_recur_coords(P, R.copy(), n - 1)

        # Use math.dist with Coordinates objects
        if c is not None and c.radius >= 0 and \
           round(math.dist(c.center, p), self.threshold_precision) <= round(c.radius, self.threshold_precision):
             return c
        else:
            R.append(p)
            return self._sec_welzl_recur_coords(P, R.copy(), n - 1)


    def _min_circle(self, points: List[Coordinates]) -> Circle:
        if not points:
            return Circle(Coordinates(0, 0), 0) # Use constructors
        elif len(points) == 1:
            return Circle(points[0], 0)
        elif len(points) == 2:
            return self._circle_from_two(points[0], points[1])
        elif len(points) == 3:
             for i in range(3):
                 p1, p2 = points[i], points[(i + 1) % 3]
                 c = self._circle_from_two(p1, p2)
                 p3 = points[(i + 2) % 3]
                 # Use math.dist with Coordinates
                 if round(math.dist(c.center, p3), self.threshold_precision) <= round(c.radius, self.threshold_precision):
                      return c

             a, b, c_pts = points[0], points[1], points[2] # Rename c to avoid conflict
             # Access .x, .y for collinearity check
             if abs(a.x * (b.y - c_pts.y) + b.x * (c_pts.y - a.y) + c_pts.x * (a.y - b.y)) < 1e-9:
                 max_dist_sq = -1
                 p1_max, p2_max = a, b
                 pairs = [(a, b), (a, c_pts), (b, c_pts)]
                 for p_i, p_j in pairs:
                     # Access .x, .y for distance check
                     d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                     if d_sq > max_dist_sq:
                         max_dist_sq = d_sq
                         p1_max, p2_max = p_i, p_j
                 return self._circle_from_two(p1_max, p2_max)
             else:
                 return self._circle_from_three(a, b, c_pts)
        else:
             Robot._logger.error("Min_circle called with > 3 points")
             return Circle(Coordinates(0,0), -1)


    def _is_point_on_circle(self, p: Coordinates, c: Circle) -> bool:
        if c is None or c.radius < 0: return False
        # Use math.dist with Coordinates objects
        distance = math.dist(p, c.center)
        return abs(distance - c.radius) < math.pow(10, -self.threshold_precision)


    def _closest_point_on_circle(self, circle: Circle, point: Coordinates) -> Coordinates:
        if circle is None or circle.radius < 0: return point

        center: Coordinates = circle.center
        radius: float = circle.radius

        # Use math.dist with Coordinates
        if math.dist(center, point) < 1e-9:
             return Coordinates(center.x + radius, center.y) # Use constructor

        # Access .x, .y
        vx, vy = point.x - center.x, point.y - center.y
        d = math.sqrt(vx**2 + vy**2)
        scale = radius / d
        cx = center.x + vx * scale
        cy = center.y + vy * scale
        return Coordinates(cx, cy) # Use constructor


    def _valid_circle(self, circle: Circle, points: List[Coordinates]) -> bool:
        if circle is None or circle.radius < 0: return False
        for p in points:
            # Use math.dist with Coordinates
            if round(math.dist(circle.center, p), self.threshold_precision) > round(circle.radius, self.threshold_precision):
                return False
        return True


    def _circle_from_two(self, a: Coordinates, b: Coordinates) -> Circle:
        # Access .x, .y
        center_x = (a.x + b.x) / 2.0
        center_y = (a.y + b.y) / 2.0
        center = Coordinates(center_x, center_y) # Use constructor
        # Use math.dist with Coordinates
        radius = math.dist(a, b) / 2.0
        return Circle(center, radius) # Use constructor


    def _circle_from_three(self, a: Coordinates, b: Coordinates, c: Coordinates) -> Circle:
        # Access .x, .y
        A = b.x - a.x; B = b.y - a.y
        C = c.x - a.x; D = c.y - a.y
        E = A * (a.x + b.x) + B * (a.y + b.y)
        F = C * (a.x + c.x) + D * (a.y + c.y)
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x))

        if abs(G) < 1e-9:
             Robot._logger.warning(f"[{self.id}] _circle_from_three called with collinear points: {a}, {b}, {c}. Using diameter fallback.")
             max_dist_sq = -1
             p1_max, p2_max = a, b
             pairs = [(a, b), (a, c), (b, c)]
             for p_i, p_j in pairs:
                 d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                 if d_sq > max_dist_sq:
                     max_dist_sq = d_sq
                     p1_max, p2_max = p_i, p_j
             return self._circle_from_two(p1_max, p2_max)

        center_x = (D * E - B * F) / G
        center_y = (A * F - C * E) / G
        center = Coordinates(center_x, center_y) # Use constructor
        # Use math.dist with Coordinates
        radius = math.dist(center, a)
        return Circle(center, radius) # Use constructor

    # --- End SEC ---

    def prettify_snapshot(self, snapshot: Dict[Id, SnapshotDetails]) -> str:
        if not snapshot: return " <empty>"
        result = ""
        sorted_ids = sorted(snapshot.keys())
        for key in sorted_ids:
            value = snapshot[key] # value is SnapshotDetails
            frozen = "*" if value.frozen else ""
            terminated = "#" if value.terminated else ""
            crashed = "!" if value.state == RobotState.CRASH else ""
            multi = f"({value.multiplicity})" if self.multiplicity_detection and value.multiplicity and value.multiplicity > 1 else ""
            state_str = value.state
            # value.pos is Coordinates
            result += f"\n\t{key}{frozen}{terminated}{crashed}{multi}: {state_str} @ {value.pos}"
        return result


    def __str__(self):
         state_str = self.state
         term_str = "#" if self.terminated else ""
         frozen_str = "*" if self.frozen else ""
         crash_str = "!" if state_str == RobotState.CRASH else ""
         # self.coordinates is Coordinates
         return f"R{self.id}{term_str}{frozen_str}{crash_str} @ {self.coordinates}, St: {state_str}, Spd: {self.speed:.2f}, VRad: {self.visibility_radius}"

print("robot.py including types/enums loaded.")
===== ./run.py =====
import sys
import json
from robot import RobotState, Algorithm, Coordinates # Only need these specifics here
from scheduler import Scheduler # Import the main class
import numpy as np

# --- Global state for the simulation ---
scheduler_instance: Scheduler|None = None
simulation_params = {}
is_running = False
current_simulation_time = 0.0
max_simulation_time = 1000.0 # Add a safety break
event_count = 0
max_events = 10000 # Add safety break

# Simple logging
def log_info(msg):
    print(f"INFO: {msg}")

def log_error(msg):
    print(f"ERROR: {msg}", file=sys.stderr)

# --- Simulation Control Functions (Callable from JS) ---

def setup_simulation(params_json_str):
    """Initializes the scheduler with parameters from JS."""
    global scheduler_instance, simulation_params, is_running, current_simulation_time
    global event_count
    log_info("Setting up simulation...")
    try:
        params = json.loads(params_json_str)
        simulation_params = params
        log_info(f"Params: {params}")

        # Generate initial positions if not provided
        num_robots = int(params.get("num_of_robots", 5))
        initial_positions = params.get("initial_positions") # Expect list of [x,y]

        if not initial_positions or len(initial_positions) != num_robots:
            log_info("Generating random initial positions...")
            width = float(params.get("width_bound", 100))
            height = float(params.get("height_bound", 100))
            seed = int(params.get("random_seed", 12345)) # Use seed from params
            generator = np.random.default_rng(seed=seed) # Use separate generator for init pos?
            x_positions = generator.uniform(low=-width / 2, high=width / 2, size=(num_robots,))
            y_positions = generator.uniform(low=-height / 2, high=height / 2, size=(num_robots,))
            initial_positions = np.column_stack((x_positions, y_positions)).tolist()
            log_info(f"Generated positions: {initial_positions}")


        # Create Scheduler instance
        scheduler_instance = Scheduler(
            seed=int(params.get("random_seed", 12345)),
            num_of_robots=num_robots,
            initial_positions=initial_positions,
            robot_speeds=float(params.get("robot_speeds", 1.0)),
            rigid_movement=bool(params.get("rigid_movement", True)),
            threshold_precision=int(params.get("threshold_precision", 5)),
            sampling_rate=float(params.get("sampling_rate", 0.1)),
            labmda_rate=float(params.get("lambda_rate", 5.0)),
            algorithm=params.get("algorithm", Algorithm.GATHERING), # Use string 'Gathering' or 'SEC'
            visibility_radius=params.get("visibility_radius"), # Pass None or float
            num_of_faults=int(params.get("num_of_faults", 0)),
            multiplicity_detection=True # Enable multiplicity always for now? Or add checkbox?
        )

        is_running = True
        current_simulation_time = 0.0
        event_count = 0
        log_info("Scheduler initialized successfully.")
        # Return the very initial state
        initial_state = {
            "status": "initialized",
            "time": 0.0,
            "robots": scheduler_instance.get_all_robot_data_for_js(),
             "message": "Simulation Initialized"
        }
        return json.dumps(initial_state)

    except Exception as e:
        log_error(f"Error setting up simulation: {e}")
        is_running = False
        error_state = {
            "status": "error",
            "time": 0.0,
            "robots": [],
             "message": f"Setup Error: {e}"
        }
        # Propagate error back to JS
        # Option 1: Return JSON with error
        return json.dumps(error_state)
        # Option 2: Raise exception (Pyodide might catch and pass to JS .catch())
        # raise e


def run_simulation_step():
    """Executes one event from the scheduler queue."""
    global scheduler_instance, is_running, current_simulation_time, event_count
    if not scheduler_instance or not is_running:
        return json.dumps({"status": "idle", "message": "Simulation not running."})

    try:
        # Safety break conditions
        if current_simulation_time > max_simulation_time:
            log_info(f"Simulation stopped: Max time ({max_simulation_time}) reached.")
            is_running = False
            return json.dumps({"status": "ended", "time": current_simulation_time, "robots": scheduler_instance.get_all_robot_data_for_js(), "message": "Ended: Max time reached"})

        event_count += 1
        if event_count > max_events:
            log_info(f"Simulation stopped: Max events ({max_events}) reached.")
            is_running = False
            return json.dumps({"status": "ended", "time": current_simulation_time, "robots": scheduler_instance.get_all_robot_data_for_js(), "message": "Ended: Max events reached"})


        exit_code, time, snapshot_data = scheduler_instance.handle_event()
        current_simulation_time = time # Update global time

        status = "running"
        message = f"Event handled (code {exit_code})"

        if scheduler_instance.terminate or exit_code == -1:
            is_running = False
            status = "ended"
            message = "Simulation Ended (Terminated)"
            log_info("Simulation terminated by scheduler.")

        # ============================ run.py =============================
        # --- inside run_simulation_step(), replace the step_result build ---
        visible = (exit_code == 99 or status != "running")  # only send robot data for VISUALIZE or final frame

        step_result = {
            "status": status,
            "time": current_simulation_time,
            "robots": scheduler_instance.get_all_robot_data_for_js() if visible else None,
            "exit_code": exit_code,
            "message": message
        }
        return json.dumps(step_result)


    except Exception as e:
        log_error(f"Error during simulation step: {e}")
        is_running = False
        # Maybe include stack trace if possible?
        import traceback
        error_state = {
            "status": "error",
            "time": current_simulation_time,
            "robots": scheduler_instance.get_all_robot_data_for_js() if scheduler_instance else [],
             "message": f"Runtime Error: {e}\n{traceback.format_exc()}"
        }
        return json.dumps(error_state)


def stop_simulation():
    """Stops the simulation loop."""
    global is_running, scheduler_instance
    log_info("Stopping simulation...")
    is_running = False
    # Maybe clean up scheduler instance?
    # scheduler_instance = None
    stopped_state = {
        "status": "stopped",
        "time": current_simulation_time,
        "robots": scheduler_instance.get_all_robot_data_for_js() if scheduler_instance else [],
        "message": "Simulation stopped by user."
    }
    return json.dumps(stopped_state)


log_info("run.py loaded.")
===== ./scheduler.py =====
# Replaces scheduler.py
from robot import (
    RobotState, Algorithm, DistributionType, SchedulerType, # Enums
    Coordinates, Circle, SnapshotDetails, Event, Time, Id, # Typedefs
    Robot, # The Robot class itself
    SimpleLogger # If needed, or define its own
)
from typing import List, Dict, Tuple, Union, Optional
import numpy as np
import heapq
import math
import random

# Helper function (can be kept here or moved into Scheduler if preferred)
def round_coordinates(coord: Coordinates, precision: int) -> Coordinates:
    if not isinstance(coord, Coordinates):
        print(f"Warning: round_coordinates received non-Coordinates type: {type(coord)}")
        return coord
    try:
        return Coordinates(round(coord.x, precision), round(coord.y, precision))
    except Exception as e:
        print(f"Error rounding coordinates {coord}: {e}")
        return coord

class Scheduler:
    _logger = SimpleLogger() # Use logger defined in robot or define here

    def __init__(
        self,
        seed: int,
        num_of_robots: int,
        initial_positions: List[List[float]], # Keep hint using List
        robot_speeds: Union[float, List[float]], # Keep hint
        algorithm: str = Algorithm.GATHERING, # Use constant from robot
        visibility_radius: Union[float, None] = None,
        # robot_colors: Union[List[str], None] = None, # Handled by JS
        rigid_movement: bool = True,
        multiplicity_detection: bool = False,
        threshold_precision: int = 5,
        sampling_rate: float = 0.2,
        labmda_rate: float = 5,
        num_of_faults: int = 0
    ):
        # ... (rest of __init__ remains the same, using imported types/constants)
        Scheduler._logger.info("--- Initializing Scheduler ---")
        Scheduler._logger.info(f"Seed: {seed}")
        self.seed = seed
        self.generator = np.random.default_rng(seed=seed)
        Robot._generator = self.generator # IMPORTANT: Provide generator to Robot class

        self.terminate = False
        self.rigid_movement = rigid_movement
        self.multiplicity_detection = multiplicity_detection
        self.visibility_radius = float(visibility_radius) if visibility_radius is not None else float('inf')
        self.threshold_precision = threshold_precision
        self.sampling_rate = sampling_rate
        self.lambda_rate = labmda_rate
        self.robots: List[Robot] = [] # Hint with Robot from robot
        self.num_of_faults = num_of_faults

        # Process speeds
        if isinstance(robot_speeds, (float, int)):
            robot_speeds_list = [float(robot_speeds)] * num_of_robots
        elif isinstance(robot_speeds, list) and len(robot_speeds) == num_of_robots:
            robot_speeds_list = [float(s) for s in robot_speeds]
        else:
            Scheduler._logger.warning(f"Invalid robot_speeds provided ({robot_speeds}). Defaulting to 1.0.")
            robot_speeds_list = [1.0] * num_of_robots

        # Validate initial positions format
        if not isinstance(initial_positions, list) or len(initial_positions) != num_of_robots:
             raise ValueError(f"Invalid initial_positions. Expected list of {num_of_robots} coordinate pairs.")

        # Create robots
        for i in range(num_of_robots):
            try:
                 # Use Coordinates constructor from robot
                coords = Coordinates(float(initial_positions[i][0]), float(initial_positions[i][1]))
            except (IndexError, TypeError, ValueError) as e:
                 raise ValueError(f"Invalid format for initial_positions[{i}]: {initial_positions[i]}. Error: {e}")

            # Use Robot constructor from robot
            new_robot = Robot(
                id=i,
                coordinates=coords,
                threshold_precision=threshold_precision,
                speed=robot_speeds_list[i],
                algorithm=algorithm,
                visibility_radius=self.visibility_radius, # Pass float or inf
                rigid_movement=self.rigid_movement,
                multiplicity_detection=self.multiplicity_detection,
            )
            self.robots.append(new_robot)
            Scheduler._logger.info(f"Created Robot: {new_robot}")


        # Assign faulty robots (using RobotState.CRASH from robot)
        if self.num_of_faults > 0 and num_of_robots > 0:
             num_faulty_to_set = min(self.num_of_faults, num_of_robots)
             if num_faulty_to_set > 0:
                 faulty_robot_indices = random.sample(range(num_of_robots), num_faulty_to_set)
                 Scheduler._logger.info(f"Setting {num_faulty_to_set} robots to faulty state: {faulty_robot_indices}")
                 for faulty_robot_index in faulty_robot_indices:
                     self.robots[faulty_robot_index].set_faulty(True) # Uses method from Robot class
                     Scheduler._logger.info(f"  -> R{faulty_robot_index} marked as faulty.")
             else:
                 Scheduler._logger.info("Number of faults requested is 0 or invalid, no robots set to faulty.")
        else:
             Scheduler._logger.info("No faults requested or no robots to make faulty.")


        self.visualization_snapshots: List[Tuple[Time, Dict[Id, SnapshotDetails]]] = [] # Use imported types

        # Initialize event queue (using Event from robot)
        self.priority_queue: List[Event] = []
        self.initialize_queue_exponential()

        self.current_time: Time = 0.0 # Use imported Time
        self.last_snapshot_time: Time = -1.0

        Scheduler._logger.info("--- Scheduler Initialized ---")

    # ... (rest of Scheduler methods remain the same, using imported types/constants)
    # Ensure SnapshotDetails, Event, RobotState, Coordinates etc. are used correctly
    # scheduler.py  – inside class Scheduler
    # ------------------------------------------------------------
    def _take_visualization_snapshot(self, time: Time) -> Dict[Id, SnapshotDetails]:
        """
        Capture the positions/states of all robots at the given time and
        store the snapshot in self.visualization_snapshots.
        Returns the snapshot so the caller can forward it to JS if needed.
        """
        snapshot = self.get_snapshot(time)          # current robot data
        self.visualization_snapshots.append((time, snapshot))
        return snapshot
    # ------------------------------------------------------------


    def get_snapshot(self, time: Time) -> Dict[Id, SnapshotDetails]:
        """ Creates a snapshot of the current state of all robots. """
        snapshot: Dict[Id, SnapshotDetails] = {} # Hint using imported types
        for robot in self.robots:
            current_pos = robot.get_position(time) # Returns Coordinates
            # Use SnapshotDetails constructor from robot
            snapshot[robot.id] = SnapshotDetails(
                pos=current_pos,
                state=robot.state,
                frozen=robot.frozen,
                terminated=robot.terminated,
                multiplicity=1
            )

        if self.multiplicity_detection:
             self._detect_multiplicity(snapshot)

        return snapshot

    # ... other methods like _take_visualization_snapshot, generate_event, schedule_visualization_event ...
    # Ensure they use the imported Event, RobotState, Time, Id correctly.

    def generate_event(self, prev_event_time: Time, robot_id: Id, current_robot_state: str) -> None:
        # ... uses self.generator, self.lambda_rate ...
        robot = self.robots[robot_id]
        time_delta = self.generator.exponential(scale=1.0 / self.lambda_rate)
        new_activation_time = prev_event_time + max(time_delta, 1e-9)

        # Use RobotState constants from robot
        next_event_state = RobotState.LOOK
        if robot.state == RobotState.CRASH:
             next_event_state = RobotState.CRASH
        elif robot.terminated:
             Scheduler._logger.info(f"Robot R{robot_id} terminated. No new event scheduled.")
             return

        # Use Event constructor from robot
        priority_event = Event(new_activation_time, robot_id, next_event_state)
        heapq.heappush(self.priority_queue, priority_event)

    def schedule_visualization_event(self, current_time: Time):
         next_vis_time = current_time + self.sampling_rate
         # Use Event constructor from robot
         vis_event = Event(next_vis_time, -1, "VISUALIZE")
         heapq.heappush(self.priority_queue, vis_event)

    def handle_event(self) -> Tuple[int, Time, Union[Dict, None]]:
        # ... uses heapq, self.priority_queue, self.current_time ...
        # ... calls self._take_visualization_snapshot, self.schedule_visualization_event ...
        # ... uses RobotState constants ...
        # ... calls robot.look, robot.move, robot.wait, robot.set_faulty ...
        # ... calls self.generate_event, self._check_global_termination ...
        # ... returns Tuple[int, Time, Union[Dict, None]] ...

        if not self.priority_queue:
            Scheduler._logger.info("Event queue empty. Simulation likely ended.")
            self.terminate = True
            return (-1, self.current_time, None)

        current_event: Event = heapq.heappop(self.priority_queue) # Type hint Event
        time: Time = current_event.time
        robot_id: Id = current_event.id
        event_state: str = current_event.state

        if time < self.current_time:
             Scheduler._logger.warning(f"Time paradox! Event time {time:.4f} is before current time {self.current_time:.4f}. Skipping event: {current_event}")
             return (0, self.current_time, None)
        self.current_time = time

        if robot_id == -1 and event_state == "VISUALIZE":
            self._take_visualization_snapshot(time)
            self.schedule_visualization_event(time)
            latest_snapshot = self.visualization_snapshots[-1][1] if self.visualization_snapshots else None
            return (99, time, latest_snapshot)

        if robot_id < 0 or robot_id >= len(self.robots):
             Scheduler._logger.error(f"Invalid robot ID {robot_id} in event: {current_event}")
             return (0, time, None)

        robot = self.robots[robot_id]
        exit_code = 0

        # Use RobotState constants
        if robot.state == RobotState.CRASH and event_state != RobotState.CRASH:
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Ignoring event {event_state} because robot is CRASHED.")
             self.generate_event(time, robot_id, robot.state)
             return (0, time, None)
        if robot.terminated and event_state != RobotState.TERMINATED:
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Ignoring event {event_state} because robot is TERMINATED.")
             return (0, time, None)

        Scheduler._logger.info(f"--- T={time:.4f} Handling Event: R{robot_id} -> {event_state} ---")

        if event_state == RobotState.LOOK:
            current_snapshot = self.get_snapshot(time)
            robot.look(current_snapshot, time)

            if robot.state == RobotState.CRASH:
                 exit_code = 5
            elif robot.terminated:
                 exit_code = 4
            elif robot.frozen:
                 exit_code = 3
                 self.generate_event(time, robot_id, robot.state)
            else:
                 robot.move(time)
                 exit_code = 2
                 distance_to_target = 0.0
                 target_pos = robot.calculated_position
                 if target_pos:
                     distance_to_target = math.dist(robot.start_position, target_pos)
                 else:
                     Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Robot decided to move but has no target! Forcing WAIT.")
                     robot.wait(time)
                     exit_code = 3
                     self.generate_event(time, robot_id, robot.state)
                     return (exit_code, time, self.get_latest_snapshot())

                 move_duration = 0.0
                 if robot.speed > 1e-9:
                      # Assuming rigid movement for simplicity here based on previous version
                     move_duration = distance_to_target / robot.speed
                     if move_duration == 0 :
                          Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Zero move duration calculated but robot was not frozen. dist={distance_to_target}")

                 move_duration = max(0, move_duration)
                 wait_event_time = time + move_duration
                 # Use Event constructor
                 wait_event = Event(wait_event_time, robot_id, RobotState.WAIT)
                 heapq.heappush(self.priority_queue, wait_event)
                 Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Scheduled WAIT event at T={wait_event_time:.4f} (duration {move_duration:.4f})")

        elif event_state == RobotState.WAIT:
             robot.wait(time)
             exit_code = 3
             self.generate_event(time, robot_id, robot.state)

        elif event_state == RobotState.MOVE:
             Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Received unexpected MOVE event. State: {robot.state}. Ignoring.")
             exit_code = 0

        elif event_state == RobotState.CRASH:
             robot.set_faulty(True)
             exit_code = 5
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Marked as CRASHED by event.")

        else:
             Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Unhandled event state '{event_state}'")
             exit_code = 0

        if self._check_global_termination():
             Scheduler._logger.info(f"--- T={time:.4f} Global Termination Condition Met ---")
             self.terminate = True
             return (-1, time, self.get_snapshot(time))

        latest_snapshot = self.visualization_snapshots[-1][1] if self.visualization_snapshots else self.get_snapshot(time)
        return (exit_code, time, latest_snapshot)


    def initialize_queue_exponential(self) -> None:
        # ... uses self.generator, self.lambda_rate, self.robots ...
        # ... uses RobotState, Event, Time, Id ...
        Scheduler._logger.info("Initializing event queue with exponential distribution...")
        initial_times = self.generator.exponential(scale=1.0 / self.lambda_rate, size=len(self.robots))
        self.priority_queue = []
        for i, robot in enumerate(self.robots):
             initial_state = RobotState.LOOK
             if robot.state == RobotState.CRASH:
                  initial_state = RobotState.CRASH
             event_time = max(0, initial_times[i])
             # Use Event constructor
             event = Event(event_time, robot.id, initial_state)
             self.priority_queue.append(event)
             Scheduler._logger.info(f"  Initial event for R{robot.id}: {initial_state} at T={event_time:.4f}")

        self.schedule_visualization_event(0.0)
        heapq.heapify(self.priority_queue)
        Scheduler._logger.info("Event queue initialized.")


    def _check_global_termination(self) -> bool:
        # ... uses self.robots, RobotState ...
        num_non_crashed = 0
        all_terminated = True
        for robot in self.robots:
            if robot.state != RobotState.CRASH:
                num_non_crashed += 1
                if not robot.terminated:
                    all_terminated = False
                    break # No need to check further

        if num_non_crashed == 0 and len(self.robots) > 0:
             Scheduler._logger.info("Global termination: All robots have crashed.")
             return True
        if num_non_crashed > 0 and all_terminated:
             Scheduler._logger.info("Global termination: All non-crashed robots are terminated.")
             return True

        return False

    def _detect_multiplicity(self, snapshot: Dict[Id, SnapshotDetails]):
        # ... uses SnapshotDetails, Coordinates, Id, math.dist, round_coordinates ...
        positions_list: List[Tuple[Coordinates, Id]] = []
        for robot_id, details in snapshot.items():
             if details.pos:
                positions_list.append((details.pos, robot_id))

        positions_list.sort(key=lambda item: (item[0].x, item[0].y)) # Access .x, .y

        n = len(positions_list)
        visited = [False] * n
        multiplicity_groups: List[List[Id]] = []

        for i in range(n):
            if visited[i]: continue
            current_group = [positions_list[i][1]]
            visited[i] = True
            # pos1_rounded = round_coordinates(positions_list[i][0], self.threshold_precision) # Can use rounding or dist

            for j in range(i + 1, n):
                if visited[j]: continue
                # pos2_rounded = round_coordinates(positions_list[j][0], self.threshold_precision)
                # if pos1_rounded == pos2_rounded:

                # Use distance check which might be more robust
                distance = math.dist(positions_list[i][0], positions_list[j][0])
                if distance < math.pow(10, -self.threshold_precision):
                    visited[j] = True
                    current_group.append(positions_list[j][1])

            if len(current_group) > 0:
                multiplicity_groups.append(current_group)

        for group in multiplicity_groups:
            count = len(group)
            if count > 1:
                for robot_id in group:
                    details = snapshot[robot_id]
                    # Use _replace for NamedTuple update
                    snapshot[robot_id] = details._replace(multiplicity=count)


    def get_latest_snapshot(self) -> Union[Dict[Id, SnapshotDetails], None]:
        if self.visualization_snapshots:
            return self.visualization_snapshots[-1][1]
        else:
            return self.get_snapshot(self.current_time)


    def get_all_robot_data_for_js(self) -> List[Dict]:
        # ... uses self.robots, RobotState, Coordinates, Circle ...
        robot_data = []
        latest_snap = self.get_latest_snapshot() # Get snapshot once for multiplicity

        for robot in self.robots:
             pos = robot.get_position(self.current_time) # Returns Coordinates
             multiplicity = 1 # Default
             if latest_snap and robot.id in latest_snap:
                 multiplicity = latest_snap[robot.id].multiplicity or 1

             # Prepare SEC data if available
             sec_data = None
             if robot.sec: # Check if robot.sec (Circle) exists
                  # Access .center.x, .center.y, .radius
                 sec_data = {"center_x": robot.sec.center.x, "center_y": robot.sec.center.y, "radius": robot.sec.radius}

             # Prepare target data if available
             target_x = None
             target_y = None
             if robot.calculated_position: # Check if Coordinates object exists
                 target_x = robot.calculated_position.x
                 target_y = robot.calculated_position.y

             robot_data.append({
                 "id": robot.id,
                 "x": pos.x, # Access .x
                 "y": pos.y, # Access .y
                 "state": robot.state,
                 "frozen": robot.frozen,
                 "terminated": robot.terminated,
                 "crashed": robot.state == RobotState.CRASH,
                 "multiplicity": multiplicity, # Get from snapshot lookup
                 "sec": sec_data,
                 "target_x": target_x,
                 "target_y": target_y,
                 "speed": robot.speed,
                 "visibility_radius": robot.visibility_radius if robot.visibility_radius != float('inf') else None
             })

        return robot_data