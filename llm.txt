# LLM input file


===== ./index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pyodide Robot Sim</title>
    <link rel="stylesheet" href="styles.css" />
    <!-- Load Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js"></script>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>Simulation Controls</h2>
            <div id="status">Loading Pyodide...</div>

            <div class="control-group">
                <label for="algorithm">Algorithm:</label>
                <select id="algorithm">
                    <option value="Gathering" selected>Gathering</option>
                    <option value="SEC">SEC (Smallest Enclosing Circle)</option>
                </select>
            </div>

            <div class="control-group slider-group">
                <label for="num_robots">Number of Robots (<span id="num_robots_val">5</span>):</label>
                <input type="range" id="num_robots" min="1" max="50" value="5">
            </div>

            <div class="control-group slider-group">
                <label for="robot_speed">Robot Speed (<span id="robot_speed_val">1.0</span>):</label>
                <input type="range" id="robot_speed" min="0.1" max="10" value="1.0" step="0.1">
            </div>

            <div class="control-group slider-group">
                <label for="visibility_radius">Visibility Radius (<span id="visibility_radius_val">150</span>):</label>
                <input type="range" id="visibility_radius" min="10" max="1000" value="150" step="10">
                 <input type="checkbox" id="infinite_visibility" title="Infinite Visibility"> Inf.
            </div>

             <div class="control-group slider-group">
                <label for="num_faults">Faulty Robots (<span id="num_faults_val">0</span>):</label>
                <input type="range" id="num_faults" min="0" max="10" value="0" step="1">
            </div>

            <div class="control-group">
                 <label for="rigid_movement">Rigid Movement:</label>
                 <input type="checkbox" id="rigid_movement" checked>
            </div>

            <hr>
            <h3>Advanced / Environment</h3>

             <div class="control-group slider-group">
                <label for="width_bound">World Width (<span id="width_bound_val">200</span>):</label>
                <input type="range" id="width_bound" min="50" max="1000" value="200" step="10">
            </div>
             <div class="control-group slider-group">
                <label for="height_bound">World Height (<span id="height_bound_val">200</span>):</label>
                <input type="range" id="height_bound" min="50" max="1000" value="200" step="10">
            </div>

             <div class="control-group slider-group">
                <label for="lambda_rate">Activation Rate (Î») (<span id="lambda_rate_val">5.0</span>):</label>
                <input type="range" id="lambda_rate" min="0.1" max="20" value="5.0" step="0.1">
            </div>

            <div class="control-group slider-group">
                <label for="sampling_rate">Vis Sample Rate (s) (<span id="sampling_rate_val">0.1</span>):</label>
                <input type="range" id="sampling_rate" min="0.05" max="1.0" value="0.1" step="0.05">
            </div>

             <div class="control-group slider-group">
                <label for="threshold_precision">Precision (1e-X) (<span id="threshold_precision_val">5</span>):</label>
                <input type="range" id="threshold_precision" min="2" max="10" value="5" step="1">
            </div>

             <div class="control-group">
                <label for="random_seed">Random Seed:</label>
                <input type="number" id="random_seed" value="12345">
            </div>


            <button id="start_button" disabled>Start Simulation</button>
            <button id="stop_button" disabled>Stop Simulation</button>

            <div id="sim_time">Time: 0.00</div>
             <div id="sim_message"></div>

        </div>
        <div id="visualization">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <!-- Load the main JavaScript -->
    <script defer src="main.js"></script>
</body>
</html>
===== ./main.js =====
console.log("main.js started");

// --- DOM Elements ---
const statusDiv = document.getElementById('status');
const startButton = document.getElementById('start_button');
const stopButton = document.getElementById('stop_button');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const simTimeDiv = document.getElementById('sim_time');
const simMessageDiv = document.getElementById('sim_message');

// Input Elements
const algorithmSelect = document.getElementById('algorithm');
const numRobotsSlider = document.getElementById('num_robots');
const numRobotsVal = document.getElementById('num_robots_val');
const robotSpeedSlider = document.getElementById('robot_speed');
const robotSpeedVal = document.getElementById('robot_speed_val');
const visibilityRadiusSlider = document.getElementById('visibility_radius');
const visibilityRadiusVal = document.getElementById('visibility_radius_val');
const infiniteVisibilityCheckbox = document.getElementById('infinite_visibility');
const numFaultsSlider = document.getElementById('num_faults');
const numFaultsVal = document.getElementById('num_faults_val');
const rigidMovementCheckbox = document.getElementById('rigid_movement');
const widthBoundSlider = document.getElementById('width_bound');
const widthBoundVal = document.getElementById('width_bound_val');
const heightBoundSlider = document.getElementById('height_bound');
const heightBoundVal = document.getElementById('height_bound_val');
const lambdaRateSlider = document.getElementById('lambda_rate');
const lambdaRateVal = document.getElementById('lambda_rate_val');
const samplingRateSlider = document.getElementById('sampling_rate');
const samplingRateVal = document.getElementById('sampling_rate_val');
const thresholdPrecisionSlider = document.getElementById('threshold_precision');
const thresholdPrecisionVal = document.getElementById('threshold_precision_val');
const randomSeedInput = document.getElementById('random_seed');

// --- Pyodide and Simulation State ---
let pyodide = null;
let simulationRunning = false;
let animationFrameId = null;
let pythonRunner = null; // Will hold Python functions like setup_simulation, run_simulation_step

// --- Canvas Drawing Configuration ---
const robotRadius = 5;
let scale = 2; // Pixels per simulation unit
let offsetX = 0; // Canvas center X
let offsetY = 0; // Canvas center Y
const colors = ["#FF0000", "#0000FF", "#008000", "#FFA500", "#800080", "#00FFFF", "#FF00FF", "#4682B4", "#FFD700", "#32CD32"]; // Add more colors if needed

// --- Helper Functions ---

function updateStatus(message) {
    console.log("Status:", message);
    if (statusDiv) statusDiv.textContent = message;
}

function updateSimMessage(message) {
    console.log("Sim Message:", message);
    if (simMessageDiv) simMessageDiv.textContent = message;
     if (message && message.toLowerCase().includes("error")) {
          simMessageDiv.style.color = 'red';
          simMessageDiv.style.fontWeight = 'bold';
     } else {
          simMessageDiv.style.color = 'black';
          simMessageDiv.style.fontWeight = 'normal';
     }
}


function updateSliderValue(slider, span) {
    if (slider && span) {
        span.textContent = slider.value;
    }
}

function resizeCanvas() {
    const vizDiv = document.getElementById('visualization');
    if (!vizDiv) return;
    const width = vizDiv.clientWidth - 20; // Subtract padding
    const height = vizDiv.clientHeight - 20;
    canvas.width = width;
    canvas.height = height;
    offsetX = canvas.width / 2;
    offsetY = canvas.height / 2;
    // Determine scale based on world bounds and canvas size
    const worldWidth = parseFloat(widthBoundSlider.value);
    const worldHeight = parseFloat(heightBoundSlider.value);
    scale = Math.min(canvas.width / worldWidth, canvas.height / worldHeight) * 0.9; // Add some padding

    console.log(`Canvas resized: ${width}x${height}, Scale: ${scale}, Offset: (${offsetX}, ${offsetY})`);
    // Redraw if simulation was running? Or wait for next step?
    // For now, let the next step handle redraw.
}

// --- Pyodide Initialization ---

async function loadPyodideAndPackages() {
    updateStatus("Loading Pyodide runtime...");
    try {
        pyodide = await loadPyodide({
             // indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/" // Optional: specify indexURL
        });
        updateStatus("Pyodide loaded. Loading packages...");
        await pyodide.loadPackage(["numpy", "micropip"]); // Need numpy, micropip helpful for fetching
        updateStatus("Packages loaded. Fetching Python code...");

        // Fetch Python code
        const pythonFiles = [
            './robot.py',
            './scheduler.py', 
            './run.py'
        ];

        for (const filePath of pythonFiles) {
            updateStatus(`Fetching ${filePath}...`);
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`Failed to fetch ${filePath}: ${response.statusText}`);
            }
            const pythonCode = await response.text();
            updateStatus(`Running ${filePath}...`);
            pyodide.runPython(pythonCode);
        }

        updateStatus("Python code loaded. Ready.");
        pythonRunner = pyodide.globals.get('simulation_runner'); // Get the module proxy
        startButton.disabled = false;

    } catch (error) {
        updateStatus(`Error initializing Pyodide or loading code: ${error}`);
        console.error("Pyodide loading error:", error);
        startButton.disabled = true;
        stopButton.disabled = true;
    }
}

// --- Simulation Control ---

async function startSimulation() {
    if (simulationRunning || !pyodide || !pythonRunner) return;
    updateStatus("Starting simulation...");
    startButton.disabled = true;
    stopButton.disabled = false;
    simulationRunning = true;
    updateSimMessage(""); // Clear previous messages

    // Gather parameters
    const params = {
        algorithm: algorithmSelect.value,
        num_of_robots: parseInt(numRobotsSlider.value),
        robot_speeds: parseFloat(robotSpeedSlider.value),
        visibility_radius: infiniteVisibilityCheckbox.checked ? null : parseFloat(visibilityRadiusSlider.value),
        num_of_faults: parseInt(numFaultsSlider.value),
        rigid_movement: rigidMovementCheckbox.checked,
        width_bound: parseFloat(widthBoundSlider.value),
        height_bound: parseFloat(heightBoundSlider.value),
        lambda_rate: parseFloat(lambdaRateSlider.value),
        sampling_rate: parseFloat(samplingRateSlider.value),
        threshold_precision: parseInt(thresholdPrecisionSlider.value),
        random_seed: parseInt(randomSeedInput.value),
        // Add other params as needed
        initial_positions: [] // Let Python handle generation for now
    };

    console.log("Simulation Params:", params);
    resizeCanvas(); // Ensure canvas size and scale are set based on bounds

    try {
        // Call Python setup function
        const setupResultJson = await pythonRunner.setup_simulation(JSON.stringify(params));
        const setupResult = JSON.parse(setupResultJson);

        if (setupResult.status === 'error') {
             throw new Error(`Setup failed: ${setupResult.message}`);
        }

        updateStatus("Simulation running...");
        updateSimMessage(setupResult.message || "Running...");
        simTimeDiv.textContent = `Time: ${setupResult.time.toFixed(2)}`;

        // Draw initial state
        drawSimulation(setupResult.robots);

        // Start the animation loop
        animationFrameId = requestAnimationFrame(simulationStep);

    } catch (error) {
        updateStatus("Error starting simulation.");
        updateSimMessage(`Error: ${error.message}`);
        console.error("Simulation start error:", error);
        simulationRunning = false;
        startButton.disabled = false;
        stopButton.disabled = true;
    }
}

function stopSimulation() {
    if (!simulationRunning || !pyodide || !pythonRunner) return;
    updateStatus("Stopping simulation...");
    simulationRunning = false; // Signal loop to stop
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    startButton.disabled = false;
    stopButton.disabled = true;

    try {
         // Call Python stop function (optional, for cleanup)
        const stopResultJson = pythonRunner.stop_simulation();
        const stopResult = JSON.parse(stopResultJson);
        updateSimMessage(stopResult.message || "Simulation stopped.");
        updateStatus("Simulation stopped.");
    } catch (error) {
        console.error("Error calling Python stop function:", error);
        updateSimMessage("Simulation stopped (with cleanup error).");
        updateStatus("Simulation stopped.");
    }
}

async function simulationStep() {
    if (!simulationRunning || !pyodide || !pythonRunner) {
        // Ensure buttons are correct if loop stops unexpectedly
        startButton.disabled = false;
        stopButton.disabled = true;
        updateStatus("Simulation stopped unexpectedly.");
        return;
    }

    try {
        // Call Python step function
        const stepResultJson = await pythonRunner.run_simulation_step();
        const result = JSON.parse(stepResultJson);

        // Update UI
        simTimeDiv.textContent = `Time: ${result.time.toFixed(2)}`;
        if (result.message) {
            // Only update message if it's significant (not just "event handled")
             if (result.status !== 'running' || !result.message.startsWith("Event handled")) {
                  updateSimMessage(result.message);
             }
        }

        // Draw current state
        if (result.robots) {
            drawSimulation(result.robots);
        }

        // Check simulation status
        if (result.status === 'ended' || result.status === 'error' || result.status === 'stopped') {
            simulationRunning = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            updateStatus(`Simulation ${result.status}.`);
            if (result.status === 'error') {
                 console.error("Simulation Error:", result.message);
            }
        }

    } catch (error) {
        console.error("Error during simulation step:", error);
        updateStatus("Simulation Error!");
        updateSimMessage(`Runtime Error: ${error.message}`);
        simulationRunning = false;
        startButton.disabled = false;
        stopButton.disabled = true;
    }

    // Request next frame if still running
    if (simulationRunning) {
        animationFrameId = requestAnimationFrame(simulationStep);
    }
}


// --- Canvas Drawing ---

function transformCoords(x, y) {
    // Translate simulation coords (origin at 0,0) to canvas coords (origin top-left)
    // Apply scaling and centering offset
    return {
        x: offsetX + x * scale,
        y: offsetY - y * scale // Y is inverted in canvas
    };
}

function drawSimulation(robots) {
    if (!ctx || !robots) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw world boundaries (optional)
    const worldW = parseFloat(widthBoundSlider.value);
    const worldH = parseFloat(heightBoundSlider.value);
    const topLeft = transformCoords(-worldW / 2, worldH / 2);
    const bottomRight = transformCoords(worldW / 2, -worldH / 2);
    ctx.strokeStyle = "#cccccc";
    ctx.lineWidth = 1;
    ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);


    // Draw robots
    robots.forEach((robot, index) => {
        const { x: canvasX, y: canvasY } = transformCoords(robot.x, robot.y);

        // Determine color
        let color = colors[robot.id % colors.length];
        if (robot.crashed) color = "#404040"; // Gray for crashed
        else if (robot.terminated) color = "#a0a0a0"; // Lighter gray for terminated

        ctx.fillStyle = color;
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 1;

        // Draw robot body
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, robotRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

         // Draw visibility radius (if finite and enabled)
         if (robot.visibility_radius !== null && robot.visibility_radius > 0 && !robot.crashed && !robot.terminated) {
             ctx.strokeStyle = "rgba(100, 100, 200, 0.3)"; // Light blue, semi-transparent
             ctx.lineWidth = 1;
             ctx.beginPath();
             ctx.arc(canvasX, canvasY, robot.visibility_radius * scale, 0, Math.PI * 2);
             ctx.stroke();
         }


        // Draw state indicator / other info
        ctx.fillStyle = "#000000";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        let statusText = `${robot.id}`;
        if (robot.state === 'MOVE') statusText += ' M';
        if (robot.frozen) statusText += '*'; // Frozen indicator
        if (robot.terminated) statusText += '#'; // Terminated indicator
        if (robot.crashed) statusText += '!'; // Crashed indicator
        if (robot.multiplicity > 1) statusText += `(${robot.multiplicity})`; // Multiplicity

        ctx.fillText(statusText, canvasX, canvasY + robotRadius + 10);

        // Draw target position and line (if moving/has target)
        if (robot.state === 'MOVE' && robot.target_x !== null && robot.target_y !== null) {
            const { x: targetX, y: targetY } = transformCoords(robot.target_x, robot.target_y);
            // Draw small target marker
            ctx.strokeStyle = color; // Use robot's color for target line
            ctx.fillStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(targetX - 3, targetY - 3);
            ctx.lineTo(targetX + 3, targetY + 3);
            ctx.moveTo(targetX - 3, targetY + 3);
            ctx.lineTo(targetX + 3, targetY - 3);
            ctx.stroke();
            // Draw line from robot to target
            ctx.beginPath();
            ctx.moveTo(canvasX, canvasY);
            ctx.lineTo(targetX, targetY);
            ctx.setLineDash([2, 3]); // Dashed line
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
        }

         // Draw SEC (if available and algorithm is SEC)
         if (robot.sec && algorithmSelect.value === 'SEC' && !robot.crashed && !robot.terminated) {
             const { center_x, center_y, radius } = robot.sec;
             if (radius >= 0) { // Check for valid radius
                 const { x: secX, y: secY } = transformCoords(center_x, center_y);
                 const secRadiusCanvas = radius * scale;

                 ctx.strokeStyle = "rgba(255, 165, 0, 0.6)"; // Orange, semi-transparent
                 ctx.lineWidth = 2;
                 ctx.beginPath();
                 ctx.arc(secX, secY, secRadiusCanvas, 0, Math.PI * 2);
                 ctx.stroke();
             }
         }
    });
}


// --- Event Listeners ---

startButton.addEventListener('click', startSimulation);
stopButton.addEventListener('click', stopSimulation);
window.addEventListener('resize', resizeCanvas); // Adjust canvas on window resize

// Slider value displays
numRobotsSlider.addEventListener('input', () => updateSliderValue(numRobotsSlider, numRobotsVal));
robotSpeedSlider.addEventListener('input', () => updateSliderValue(robotSpeedSlider, robotSpeedVal));
visibilityRadiusSlider.addEventListener('input', () => updateSliderValue(visibilityRadiusSlider, visibilityRadiusVal));
numFaultsSlider.addEventListener('input', () => updateSliderValue(numFaultsSlider, numFaultsVal));
widthBoundSlider.addEventListener('input', () => { updateSliderValue(widthBoundSlider, widthBoundVal); resizeCanvas(); });
heightBoundSlider.addEventListener('input', () => { updateSliderValue(heightBoundSlider, heightBoundVal); resizeCanvas(); });
lambdaRateSlider.addEventListener('input', () => updateSliderValue(lambdaRateSlider, lambdaRateVal));
samplingRateSlider.addEventListener('input', () => updateSliderValue(samplingRateSlider, samplingRateVal));
thresholdPrecisionSlider.addEventListener('input', () => updateSliderValue(thresholdPrecisionSlider, thresholdPrecisionVal));

// Infinite visibility checkbox logic
infiniteVisibilityCheckbox.addEventListener('change', () => {
    visibilityRadiusSlider.disabled = infiniteVisibilityCheckbox.checked;
    if (infiniteVisibilityCheckbox.checked) {
         visibilityRadiusVal.textContent = "Inf";
    } else {
         updateSliderValue(visibilityRadiusSlider, visibilityRadiusVal); // Restore numeric value
    }
});

// Initial setup calls
updateSliderValue(numRobotsSlider, numRobotsVal);
updateSliderValue(robotSpeedSlider, robotSpeedVal);
updateSliderValue(visibilityRadiusSlider, visibilityRadiusVal);
updateSliderValue(numFaultsSlider, numFaultsVal);
updateSliderValue(widthBoundSlider, widthBoundVal);
updateSliderValue(heightBoundSlider, heightBoundVal);
updateSliderValue(lambdaRateSlider, lambdaRateVal);
updateSliderValue(samplingRateSlider, samplingRateVal);
updateSliderValue(thresholdPrecisionSlider, thresholdPrecisionVal);

// Disable slider if infinite checked initially
visibilityRadiusSlider.disabled = infiniteVisibilityCheckbox.checked;
 if (infiniteVisibilityCheckbox.checked) {
     visibilityRadiusVal.textContent = "Inf";
 }

// Initial canvas setup
resizeCanvas();
drawSimulation([]); // Draw empty canvas initially

// --- Load Pyodide ---
loadPyodideAndPackages();

console.log("main.js loaded and initial setup done.");
===== ./robot.py =====
import math
from typing import NamedTuple, Callable, List, Dict, Tuple, Union # Keep Union for type hints if needed

class RobotState:
    LOOK = "LOOK"
    MOVE = "MOVE"
    WAIT = "WAIT"
    TERMINATED = "TERMINATED"
    CRASH = "CRASH"

    @staticmethod
    def next_state(current_state: str) -> str: # Add type hints here too
        if current_state == RobotState.CRASH:
            return RobotState.CRASH
        elif current_state == RobotState.LOOK:
            return RobotState.MOVE
        elif current_state == RobotState.MOVE:
            return RobotState.WAIT
        elif current_state == RobotState.WAIT:
            return RobotState.LOOK
        return current_state # Default fallback

class SchedulerType:
    ASYNC = "Async"

class DistributionType:
    EXPONENTIAL = "Exponential"

class Algorithm:
    GATHERING = "Gathering"
    SEC = "SEC"


Time = float
Id = int

class Coordinates(NamedTuple):
    x: float
    y: float
    def __str__(self):
        return f"({float(self.x):.4f}, {float(self.y):.4f})"

class Circle(NamedTuple):
    center: Coordinates
    radius: float
    def __str__(self):
        return f"Center: {self.center} ; radius: {float(self.radius):.4f}"

class SnapshotDetails(NamedTuple):
    pos: Coordinates
    state: str
    frozen: bool
    terminated: bool
    multiplicity: Union[int, None] # Use Union for type hint clarity

class Event(NamedTuple):
    time: Time # Use type alias
    id: Id    # Use type alias
    state: str

class Orientation(NamedTuple): # Keep definition even if unused for now
    translation: float
    rotation: float
    reflection: float

# --- Robot Class Definition (Mostly unchanged logic) ---

# Simple logging replacement
class SimpleLogger:
    def info(self, msg):
        print(f"INFO: {msg}")
    def warning(self, msg):
        print(f"WARN: {msg}")
    def error(self, msg):
        print(f"ERROR: {msg}")

class Robot:
    _logger = SimpleLogger()
    _generator = None # Will be set by scheduler

    def __init__(
        self,
        id: Id, # Use type alias
        coordinates: Coordinates,
        algorithm: str, # e.g., Algorithm.GATHERING
        speed: float = 1.0,
        color: Union[str, None] = None, # Use Union
        visibility_radius: Union[float, None] = None, # Use Union
        # orientation: Union[Orientation, None] = None, # Keep if needed later
        # obstructed_visibility: bool = False, # Keep if needed later
        multiplicity_detection: bool = False,
        rigid_movement: bool = False,
        threshold_precision: float = 5,
    ):
        self.speed = speed
        self.color = color
        # Ensure visibility_radius is float or inf
        self.visibility_radius = float(visibility_radius) if visibility_radius is not None else float('inf')
        # self.obstructed_visibility = obstructed_visibility
        self.multiplicity_detection = multiplicity_detection
        self.rigid_movement = rigid_movement
        # self.orientation = orientation
        self.start_time: Union[Time, None] = None # Use type alias and Union
        self.end_time: Union[Time, None] = None   # Use type alias and Union
        self.state: str = RobotState.WAIT # Use constant from this file
        self.start_position: Coordinates = coordinates
        self.calculated_position: Union[Coordinates, None] = None
        self.number_of_activations: int = 0
        self.travelled_distance: float = 0.0
        self.snapshot: Union[Dict[Id, SnapshotDetails], None] = None # Use Dict, Id
        self.coordinates: Coordinates = coordinates
        self.id: Id = id # Use type alias
        self.threshold_precision: float = threshold_precision
        self.frozen: bool = False
        self.terminated: bool = False
        self.sec: Union[Circle, None] = None # Stores the calculated SEC

        # Assign algorithm type based on the input string constant
        if algorithm == Algorithm.GATHERING:
             self.algorithm_type = Algorithm.GATHERING
        elif algorithm == Algorithm.SEC:
             self.algorithm_type = Algorithm.SEC
        else:
             raise ValueError(f"Unknown algorithm: {algorithm}")


    def set_faulty(self, faulty: bool) -> None:
        if faulty:
            self.state = RobotState.CRASH

    def look(
        self,
        snapshot: Dict[Id, SnapshotDetails], # Use Dict, Id
        time: Time,                         # Use Time
    ) -> None:
        if self.state == RobotState.CRASH: return

        self.state = RobotState.LOOK

        self.snapshot = {}
        for key, value in snapshot.items():
            if self.visibility_radius == float('inf') or self._robot_is_visible(value.pos):
                transformed_pos = self._convert_coordinate(value.pos)
                # Make sure SnapshotDetails is used correctly
                self.snapshot[key] = SnapshotDetails(
                    transformed_pos,
                    value.state,
                    value.frozen,
                    value.terminated,
                    value.multiplicity,
                )

        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} LOOK    -- Snapshot {self.prettify_snapshot(self.snapshot)}"
        )

        active_visible_robots = [r for r_id, r in self.snapshot.items() if not r.terminated and r.state != RobotState.CRASH]

        if len(active_visible_robots) <= 1 and self.id in self.snapshot:
            self.frozen = True
            self.terminated = True
            Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} TERMINATED (only self visible)")
            self.wait(time)
            return

        algo, algo_terminal = self._select_algorithm()
        # Type hint for algo: Callable[[], Tuple[Coordinates, List[any]]]
        # Type hint for algo_terminal: Callable[[Coordinates, List[any]], bool]
        self.calculated_position = self._compute(algo, algo_terminal, time)
        pos_str = (
            f"({self.calculated_position.x:.4f}, {self.calculated_position.y:.4f})" # Access .x, .y
            if self.calculated_position
            else "None"
        )
        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} COMPUTE -- Computed Pos: {pos_str}"
        )

        if self.terminated:
             Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} TERMINATED (condition met in compute)")
             self.wait(time)
             return

        if self.calculated_position is None or \
           math.dist(self.calculated_position, self.coordinates) < 10**-self.threshold_precision:
            self.frozen = True
            Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} FROZEN (target reached or no movement)")
            self.wait(time)
        else:
            self.frozen = False

    def _compute(
        self,
        algo: Callable[[], Tuple[Coordinates, List[any]]],
        check_terminal: Callable[[Coordinates, List[any]], bool],
        time: Time
    ) -> Union[Coordinates, None]:
        try:
            coord, extra_args = algo()

            if check_terminal is None:
                Robot._logger.error("Algorithm termination function not passed in")
                return self.coordinates

            if check_terminal(coord, extra_args):
                Robot._logger.info(f"[{time:.2f}] {{R{self.id}}} Termination condition met during compute.")
                self.terminated = True
                return coord # Return calculated coord, but flag is set

            else:
                 return coord

        except Exception as e:
            Robot._logger.error(f"[{time:.2f}] {{R{self.id}}} Error during _compute: {e}")
            self.frozen = True
            return self.coordinates


    def move(self, start_time: Time) -> None:
        if self.state == RobotState.CRASH or self.terminated or self.frozen:
             Robot._logger.info(f"[{start_time:.2f}] {{R{self.id}}} Skipping MOVE (State: {self.state}, Term: {self.terminated}, Frozen: {self.frozen})")
             self.state = RobotState.WAIT # Ensure it goes back to WAIT if frozen/terminated/crashed tried to move
             return

        if self.calculated_position is None:
             Robot._logger.warning(f"[{start_time:.2f}] {{R{self.id}}} MOVE called with no calculated_position. Skipping move.")
             self.state = RobotState.WAIT
             return

        self.state = RobotState.MOVE
        Robot._logger.info(f"[{start_time:.2f}] {{R{self.id}}} MOVE -> {self.calculated_position}")
        self.start_time = start_time
        self.start_position = self.coordinates

    def wait(self, time: Time) -> None:
        final_pos = self.get_position(time)
        current_distance = 0.0
        if self.start_time is not None and self.state == RobotState.MOVE:
             # Make sure start_position is Coordinates type
             current_distance = math.dist(self.start_position, final_pos)
             self.travelled_distance += current_distance

        self.coordinates = final_pos

        self.start_time = None
        self.end_time = time
        self.state = RobotState.WAIT

        Robot._logger.info(
            f"[{time:.2f}] {{R{self.id}}} WAIT    -- Pos: {self.coordinates} Dist: {current_distance:.4f} Total: {self.travelled_distance:.4f} Frozen: {self.frozen} Term: {self.terminated}"
        )


    def get_position(self, time: Time) -> Coordinates:
        if self.state != RobotState.MOVE or self.start_time is None or self.calculated_position is None:
            return self.coordinates

        target_distance = math.dist(self.start_position, self.calculated_position)

        if target_distance < 1e-9:
            return self.calculated_position

        elapsed_time = time - self.start_time
        distance_covered = self.speed * elapsed_time

        if distance_covered >= target_distance - (10**-self.threshold_precision):
            return self.calculated_position
        else:
            factor = distance_covered / target_distance
            interpolated_coords = self._interpolate(
                self.start_position, self.calculated_position, factor
            )
            return interpolated_coords


    def _select_algorithm(self) -> Tuple[Callable, Callable]: # Return types are complex, using Tuple[Callable, Callable]
        if self.algorithm_type == Algorithm.GATHERING:
            return (self._midpoint, self._midpoint_terminal)
        elif self.algorithm_type == Algorithm.SEC:
            return (self._smallest_enclosing_circle, self._sec_terminal)
        else:
            raise ValueError(f"Invalid algorithm type: {self.algorithm_type}")

    def _interpolate(
        self, start: Coordinates, end: Coordinates, t: float
    ) -> Coordinates:
        t = max(0.0, min(1.0, t))
        # Ensure Coordinates constructor is used
        return Coordinates(
            start.x + t * (end.x - start.x), start.y + t * (end.y - start.y)
        )

    def _convert_coordinate(self, coord: Coordinates) -> Coordinates:
        return coord

    def _robot_is_visible(self, coord: Coordinates) -> bool:
        if self.visibility_radius == float('inf'):
             return True
        distance = math.dist(self.coordinates, coord)
        return distance <= self.visibility_radius


    def _midpoint(self) -> Tuple[Coordinates, List[any]]:
        if not self.snapshot:
             Robot._logger.warning(f"{{R{self.id}}} Midpoint calculation with empty snapshot. Staying put.")
             return (self.coordinates, [])

        x = y = 0
        num_visible = 0
        for _, value in self.snapshot.items():
            x += value.pos.x # Access pos.x
            y += value.pos.y # Access pos.y
            num_visible += 1

        if num_visible == 0:
             return (self.coordinates, [])

        x /= num_visible
        y /= num_visible

        return (Coordinates(x, y), []) # Construct Coordinates


    def _midpoint_terminal(self, coord: Coordinates, args: List[any] = None) -> bool:
        if not self.snapshot:
             return True

        for robot_id, details in self.snapshot.items():
            if details.state != RobotState.CRASH:
                 # Access details.pos
                if math.dist(details.pos, coord) > math.pow(10, -self.threshold_precision):
                    return False
        return True

    # --- SEC Algorithm Methods ---
    # Ensure Coordinates, Circle, SnapshotDetails, etc. are used correctly from this file's definitions
    # Make sure .x, .y are accessed correctly on Coordinates objects

    def _smallest_enclosing_circle(self) -> Tuple[Coordinates, List[Union[Circle, None]]]:
        visible_robots_details = {rid: r for rid, r in self.snapshot.items() if r.state != RobotState.CRASH}
        points_coords: List[Coordinates] = [r.pos for r in visible_robots_details.values()] # List of Coordinates

        num_robots = len(points_coords)
        destination: Union[Coordinates, None] = None
        calculated_sec: Union[Circle, None] = None

        try:
            if num_robots == 0:
                destination = self.coordinates
                calculated_sec = None
            elif num_robots == 1:
                destination = points_coords[0]
                calculated_sec = Circle(points_coords[0], 0) # Use Circle constructor
            elif num_robots == 2:
                a, b = points_coords[0], points_coords[1]
                calculated_sec = self._circle_from_two(a, b)
                destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
            elif num_robots == 3:
                potential_sec = None
                for i in range(num_robots):
                    for j in range(i + 1, num_robots):
                        a, b = points_coords[i], points_coords[j]
                        sec_candidate = self._circle_from_two(a, b)
                        if self._valid_circle(sec_candidate, points_coords):
                            potential_sec = sec_candidate
                            break
                    if potential_sec: break

                if not potential_sec:
                     a, b, c = points_coords[0], points_coords[1], points_coords[2]
                     if abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) < 1e-9:
                         max_dist_sq = -1
                         p1, p2 = a, b
                         pairs = [(a, b), (a, c), (b, c)]
                         for p_i, p_j in pairs:
                             d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                             if d_sq > max_dist_sq:
                                 max_dist_sq = d_sq
                                 p1, p2 = p_i, p_j
                         potential_sec = self._circle_from_two(p1, p2)
                     else:
                         potential_sec = self._circle_from_three(a, b, c)

                calculated_sec = potential_sec
                if calculated_sec:
                     destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
                else:
                     Robot._logger.warning(f"[{self.id}] Failed to calculate SEC for 3 points. Staying put.")
                     destination = self.coordinates
            else: # > 3 robots
                calculated_sec = self._sec_welzl_coords(points_coords)
                if calculated_sec:
                    destination = self._closest_point_on_circle(calculated_sec, self.coordinates)
                else:
                     Robot._logger.warning(f"[{self.id}] Failed to calculate SEC via Welzl. Staying put.")
                     destination = self.coordinates

            self.sec = calculated_sec
            # Ensure destination is always Coordinates
            final_destination = destination if destination is not None else self.coordinates
            return (final_destination, [self.sec])

        except Exception as e:
            Robot._logger.error(f"[{self.id}] Error in _smallest_enclosing_circle: {e}")
            return (self.coordinates, [None])


    def _sec_terminal(self, _, args: List[Union[Circle, None]]) -> bool:
        if not args or args[0] is None:
            return False

        circle: Circle = args[0] # Now explicitly Circle type

        visible_robots_details = {rid: r for rid, r in self.snapshot.items() if r.state != RobotState.CRASH}

        if not visible_robots_details:
             return True

        for robot_id, details in visible_robots_details.items():
            # Pass details.pos (Coordinates) to is_point_on_circle
            if not self._is_point_on_circle(details.pos, circle):
                 return False
        return True


    def _sec_welzl_coords(self, points: List[Coordinates]) -> Union[Circle, None]:
        if not points: return None
        points_copy = points.copy()
        if Robot._generator is None:
             Robot._logger.error("Robot._generator not set for Welzl shuffle!")
             import random
             random.shuffle(points_copy)
        else:
            Robot._generator.shuffle(points_copy)
        return self._sec_welzl_recur_coords(points_copy, [], len(points_copy))


    def _sec_welzl_recur_coords(self, P: List[Coordinates], R: List[Coordinates], n: int) -> Circle:
        if n == 0 or len(R) == 3:
            return self._min_circle(R)

        idx = Robot._generator.integers(0, n) if n > 0 else 0
        p = P[idx]
        P[idx], P[n - 1] = P[n - 1], P[idx]

        c = self._sec_welzl_recur_coords(P, R.copy(), n - 1)

        # Use math.dist with Coordinates objects
        if c is not None and c.radius >= 0 and \
           round(math.dist(c.center, p), self.threshold_precision) <= round(c.radius, self.threshold_precision):
             return c
        else:
            R.append(p)
            return self._sec_welzl_recur_coords(P, R.copy(), n - 1)


    def _min_circle(self, points: List[Coordinates]) -> Circle:
        if not points:
            return Circle(Coordinates(0, 0), 0) # Use constructors
        elif len(points) == 1:
            return Circle(points[0], 0)
        elif len(points) == 2:
            return self._circle_from_two(points[0], points[1])
        elif len(points) == 3:
             for i in range(3):
                 p1, p2 = points[i], points[(i + 1) % 3]
                 c = self._circle_from_two(p1, p2)
                 p3 = points[(i + 2) % 3]
                 # Use math.dist with Coordinates
                 if round(math.dist(c.center, p3), self.threshold_precision) <= round(c.radius, self.threshold_precision):
                      return c

             a, b, c_pts = points[0], points[1], points[2] # Rename c to avoid conflict
             # Access .x, .y for collinearity check
             if abs(a.x * (b.y - c_pts.y) + b.x * (c_pts.y - a.y) + c_pts.x * (a.y - b.y)) < 1e-9:
                 max_dist_sq = -1
                 p1_max, p2_max = a, b
                 pairs = [(a, b), (a, c_pts), (b, c_pts)]
                 for p_i, p_j in pairs:
                     # Access .x, .y for distance check
                     d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                     if d_sq > max_dist_sq:
                         max_dist_sq = d_sq
                         p1_max, p2_max = p_i, p_j
                 return self._circle_from_two(p1_max, p2_max)
             else:
                 return self._circle_from_three(a, b, c_pts)
        else:
             Robot._logger.error("Min_circle called with > 3 points")
             return Circle(Coordinates(0,0), -1)


    def _is_point_on_circle(self, p: Coordinates, c: Circle) -> bool:
        if c is None or c.radius < 0: return False
        # Use math.dist with Coordinates objects
        distance = math.dist(p, c.center)
        return abs(distance - c.radius) < math.pow(10, -self.threshold_precision)


    def _closest_point_on_circle(self, circle: Circle, point: Coordinates) -> Coordinates:
        if circle is None or circle.radius < 0: return point

        center: Coordinates = circle.center
        radius: float = circle.radius

        # Use math.dist with Coordinates
        if math.dist(center, point) < 1e-9:
             return Coordinates(center.x + radius, center.y) # Use constructor

        # Access .x, .y
        vx, vy = point.x - center.x, point.y - center.y
        d = math.sqrt(vx**2 + vy**2)
        scale = radius / d
        cx = center.x + vx * scale
        cy = center.y + vy * scale
        return Coordinates(cx, cy) # Use constructor


    def _valid_circle(self, circle: Circle, points: List[Coordinates]) -> bool:
        if circle is None or circle.radius < 0: return False
        for p in points:
            # Use math.dist with Coordinates
            if round(math.dist(circle.center, p), self.threshold_precision) > round(circle.radius, self.threshold_precision):
                return False
        return True


    def _circle_from_two(self, a: Coordinates, b: Coordinates) -> Circle:
        # Access .x, .y
        center_x = (a.x + b.x) / 2.0
        center_y = (a.y + b.y) / 2.0
        center = Coordinates(center_x, center_y) # Use constructor
        # Use math.dist with Coordinates
        radius = math.dist(a, b) / 2.0
        return Circle(center, radius) # Use constructor


    def _circle_from_three(self, a: Coordinates, b: Coordinates, c: Coordinates) -> Circle:
        # Access .x, .y
        A = b.x - a.x; B = b.y - a.y
        C = c.x - a.x; D = c.y - a.y
        E = A * (a.x + b.x) + B * (a.y + b.y)
        F = C * (a.x + c.x) + D * (a.y + c.y)
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x))

        if abs(G) < 1e-9:
             Robot._logger.warning(f"[{self.id}] _circle_from_three called with collinear points: {a}, {b}, {c}. Using diameter fallback.")
             max_dist_sq = -1
             p1_max, p2_max = a, b
             pairs = [(a, b), (a, c), (b, c)]
             for p_i, p_j in pairs:
                 d_sq = (p_i.x - p_j.x)**2 + (p_i.y - p_j.y)**2
                 if d_sq > max_dist_sq:
                     max_dist_sq = d_sq
                     p1_max, p2_max = p_i, p_j
             return self._circle_from_two(p1_max, p2_max)

        center_x = (D * E - B * F) / G
        center_y = (A * F - C * E) / G
        center = Coordinates(center_x, center_y) # Use constructor
        # Use math.dist with Coordinates
        radius = math.dist(center, a)
        return Circle(center, radius) # Use constructor

    # --- End SEC ---

    def prettify_snapshot(self, snapshot: Dict[Id, SnapshotDetails]) -> str:
        if not snapshot: return " <empty>"
        result = ""
        sorted_ids = sorted(snapshot.keys())
        for key in sorted_ids:
            value = snapshot[key] # value is SnapshotDetails
            frozen = "*" if value.frozen else ""
            terminated = "#" if value.terminated else ""
            crashed = "!" if value.state == RobotState.CRASH else ""
            multi = f"({value.multiplicity})" if self.multiplicity_detection and value.multiplicity and value.multiplicity > 1 else ""
            state_str = value.state
            # value.pos is Coordinates
            result += f"\n\t{key}{frozen}{terminated}{crashed}{multi}: {state_str} @ {value.pos}"
        return result


    def __str__(self):
         state_str = self.state
         term_str = "#" if self.terminated else ""
         frozen_str = "*" if self.frozen else ""
         crash_str = "!" if state_str == RobotState.CRASH else ""
         # self.coordinates is Coordinates
         return f"R{self.id}{term_str}{frozen_str}{crash_str} @ {self.coordinates}, St: {state_str}, Spd: {self.speed:.2f}, VRad: {self.visibility_radius}"

print("robot.py including types/enums loaded.")
===== ./run.py =====
import sys
import json
from robot import RobotState, Algorithm, Coordinates # Only need these specifics here
from scheduler import Scheduler # Import the main class
import numpy as np

# --- Global state for the simulation ---
scheduler_instance: Scheduler|None = None
simulation_params = {}
is_running = False
current_simulation_time = 0.0
max_simulation_time = 1000.0 # Add a safety break
event_count = 0
max_events = 10000 # Add safety break

# Simple logging
def log_info(msg):
    print(f"INFO: {msg}")

def log_error(msg):
    print(f"ERROR: {msg}", file=sys.stderr)

# --- Simulation Control Functions (Callable from JS) ---

def setup_simulation(params_json_str):
    """Initializes the scheduler with parameters from JS."""
    global scheduler_instance, simulation_params, is_running, current_simulation_time
    global event_count
    log_info("Setting up simulation...")
    try:
        params = json.loads(params_json_str)
        simulation_params = params
        log_info(f"Params: {params}")

        # Generate initial positions if not provided
        num_robots = int(params.get("num_of_robots", 5))
        initial_positions = params.get("initial_positions") # Expect list of [x,y]

        if not initial_positions or len(initial_positions) != num_robots:
            log_info("Generating random initial positions...")
            width = float(params.get("width_bound", 100))
            height = float(params.get("height_bound", 100))
            seed = int(params.get("random_seed", 12345)) # Use seed from params
            generator = np.random.default_rng(seed=seed) # Use separate generator for init pos?
            x_positions = generator.uniform(low=-width / 2, high=width / 2, size=(num_robots,))
            y_positions = generator.uniform(low=-height / 2, high=height / 2, size=(num_robots,))
            initial_positions = np.column_stack((x_positions, y_positions)).tolist()
            log_info(f"Generated positions: {initial_positions}")


        # Create Scheduler instance
        scheduler_instance = Scheduler(
            seed=int(params.get("random_seed", 12345)),
            num_of_robots=num_robots,
            initial_positions=initial_positions,
            robot_speeds=float(params.get("robot_speeds", 1.0)),
            rigid_movement=bool(params.get("rigid_movement", True)),
            threshold_precision=int(params.get("threshold_precision", 5)),
            sampling_rate=float(params.get("sampling_rate", 0.1)),
            labmda_rate=float(params.get("lambda_rate", 5.0)),
            algorithm=params.get("algorithm", Algorithm.GATHERING), # Use string 'Gathering' or 'SEC'
            visibility_radius=params.get("visibility_radius"), # Pass None or float
            num_of_faults=int(params.get("num_of_faults", 0)),
            multiplicity_detection=True # Enable multiplicity always for now? Or add checkbox?
        )

        is_running = True
        current_simulation_time = 0.0
        event_count = 0
        log_info("Scheduler initialized successfully.")
        # Return the very initial state
        initial_state = {
            "status": "initialized",
            "time": 0.0,
            "robots": scheduler_instance.get_all_robot_data_for_js(),
             "message": "Simulation Initialized"
        }
        return json.dumps(initial_state)

    except Exception as e:
        log_error(f"Error setting up simulation: {e}")
        is_running = False
        error_state = {
            "status": "error",
            "time": 0.0,
            "robots": [],
             "message": f"Setup Error: {e}"
        }
        # Propagate error back to JS
        # Option 1: Return JSON with error
        return json.dumps(error_state)
        # Option 2: Raise exception (Pyodide might catch and pass to JS .catch())
        # raise e


def run_simulation_step():
    """Executes one event from the scheduler queue."""
    global scheduler_instance, is_running, current_simulation_time, event_count
    if not scheduler_instance or not is_running:
        return json.dumps({"status": "idle", "message": "Simulation not running."})

    try:
        # Safety break conditions
        if current_simulation_time > max_simulation_time:
            log_info(f"Simulation stopped: Max time ({max_simulation_time}) reached.")
            is_running = False
            return json.dumps({"status": "ended", "time": current_simulation_time, "robots": scheduler_instance.get_all_robot_data_for_js(), "message": "Ended: Max time reached"})

        event_count += 1
        if event_count > max_events:
            log_info(f"Simulation stopped: Max events ({max_events}) reached.")
            is_running = False
            return json.dumps({"status": "ended", "time": current_simulation_time, "robots": scheduler_instance.get_all_robot_data_for_js(), "message": "Ended: Max events reached"})


        exit_code, time, snapshot_data = scheduler_instance.handle_event()
        current_simulation_time = time # Update global time

        status = "running"
        message = f"Event handled (code {exit_code})"

        if scheduler_instance.terminate or exit_code == -1:
            is_running = False
            status = "ended"
            message = "Simulation Ended (Terminated)"
            log_info("Simulation terminated by scheduler.")


        # Prepare data for JS
        step_result = {
            "status": status,
            "time": current_simulation_time,
            # Use the dedicated function to get robot data in JS-friendly format
            "robots": scheduler_instance.get_all_robot_data_for_js(),
            "exit_code": exit_code,
            "message": message
            # Include snapshot if needed for debugging?
            # "snapshot": snapshot_data # This snapshot might be slightly outdated vs get_all_robot_data
        }
        return json.dumps(step_result)

    except Exception as e:
        log_error(f"Error during simulation step: {e}")
        is_running = False
        # Maybe include stack trace if possible?
        import traceback
        error_state = {
            "status": "error",
            "time": current_simulation_time,
            "robots": scheduler_instance.get_all_robot_data_for_js() if scheduler_instance else [],
             "message": f"Runtime Error: {e}\n{traceback.format_exc()}"
        }
        return json.dumps(error_state)


def stop_simulation():
    """Stops the simulation loop."""
    global is_running, scheduler_instance
    log_info("Stopping simulation...")
    is_running = False
    # Maybe clean up scheduler instance?
    # scheduler_instance = None
    stopped_state = {
        "status": "stopped",
        "time": current_simulation_time,
        "robots": scheduler_instance.get_all_robot_data_for_js() if scheduler_instance else [],
        "message": "Simulation stopped by user."
    }
    return json.dumps(stopped_state)


log_info("run.py loaded.")
===== ./scheduler.py =====
# Replaces scheduler.py
from robot import (
    RobotState, Algorithm, DistributionType, SchedulerType, # Enums
    Coordinates, Circle, SnapshotDetails, Event, Time, Id, # Typedefs
    Robot, # The Robot class itself
    SimpleLogger # If needed, or define its own
)
# Keep other necessary imports
import numpy as np
import heapq
import math
import random

# Helper function (can be kept here or moved into Scheduler if preferred)
def round_coordinates(coord: Coordinates, precision: int) -> Coordinates:
    if not isinstance(coord, Coordinates):
        print(f"Warning: round_coordinates received non-Coordinates type: {type(coord)}")
        return coord
    try:
        return Coordinates(round(coord.x, precision), round(coord.y, precision))
    except Exception as e:
        print(f"Error rounding coordinates {coord}: {e}")
        return coord

class Scheduler:
    _logger = SimpleLogger() # Use logger defined in robot or define here

    def __init__(
        self,
        seed: int,
        num_of_robots: int,
        initial_positions: List[List[float]], # Keep hint using List
        robot_speeds: Union[float, List[float]], # Keep hint
        algorithm: str = Algorithm.GATHERING, # Use constant from robot
        visibility_radius: Union[float, None] = None,
        # robot_colors: Union[List[str], None] = None, # Handled by JS
        rigid_movement: bool = True,
        multiplicity_detection: bool = False,
        threshold_precision: int = 5,
        sampling_rate: float = 0.2,
        labmda_rate: float = 5,
        num_of_faults: int = 0
    ):
        # ... (rest of __init__ remains the same, using imported types/constants)
        Scheduler._logger.info("--- Initializing Scheduler ---")
        Scheduler._logger.info(f"Seed: {seed}")
        self.seed = seed
        self.generator = np.random.default_rng(seed=seed)
        Robot._generator = self.generator # IMPORTANT: Provide generator to Robot class

        self.terminate = False
        self.rigid_movement = rigid_movement
        self.multiplicity_detection = multiplicity_detection
        self.visibility_radius = float(visibility_radius) if visibility_radius is not None else float('inf')
        self.threshold_precision = threshold_precision
        self.sampling_rate = sampling_rate
        self.lambda_rate = labmda_rate
        self.robots: List[Robot] = [] # Hint with Robot from robot
        self.num_of_faults = num_of_faults

        # Process speeds
        if isinstance(robot_speeds, (float, int)):
            robot_speeds_list = [float(robot_speeds)] * num_of_robots
        elif isinstance(robot_speeds, list) and len(robot_speeds) == num_of_robots:
            robot_speeds_list = [float(s) for s in robot_speeds]
        else:
            Scheduler._logger.warning(f"Invalid robot_speeds provided ({robot_speeds}). Defaulting to 1.0.")
            robot_speeds_list = [1.0] * num_of_robots

        # Validate initial positions format
        if not isinstance(initial_positions, list) or len(initial_positions) != num_of_robots:
             raise ValueError(f"Invalid initial_positions. Expected list of {num_of_robots} coordinate pairs.")

        # Create robots
        for i in range(num_of_robots):
            try:
                 # Use Coordinates constructor from robot
                coords = Coordinates(float(initial_positions[i][0]), float(initial_positions[i][1]))
            except (IndexError, TypeError, ValueError) as e:
                 raise ValueError(f"Invalid format for initial_positions[{i}]: {initial_positions[i]}. Error: {e}")

            # Use Robot constructor from robot
            new_robot = Robot(
                id=i,
                coordinates=coords,
                threshold_precision=threshold_precision,
                speed=robot_speeds_list[i],
                algorithm=algorithm,
                visibility_radius=self.visibility_radius, # Pass float or inf
                rigid_movement=self.rigid_movement,
                multiplicity_detection=self.multiplicity_detection,
            )
            self.robots.append(new_robot)
            Scheduler._logger.info(f"Created Robot: {new_robot}")


        # Assign faulty robots (using RobotState.CRASH from robot)
        if self.num_of_faults > 0 and num_of_robots > 0:
             num_faulty_to_set = min(self.num_of_faults, num_of_robots)
             if num_faulty_to_set > 0:
                 faulty_robot_indices = random.sample(range(num_of_robots), num_faulty_to_set)
                 Scheduler._logger.info(f"Setting {num_faulty_to_set} robots to faulty state: {faulty_robot_indices}")
                 for faulty_robot_index in faulty_robot_indices:
                     self.robots[faulty_robot_index].set_faulty(True) # Uses method from Robot class
                     Scheduler._logger.info(f"  -> R{faulty_robot_index} marked as faulty.")
             else:
                 Scheduler._logger.info("Number of faults requested is 0 or invalid, no robots set to faulty.")
        else:
             Scheduler._logger.info("No faults requested or no robots to make faulty.")


        self.visualization_snapshots: List[Tuple[Time, Dict[Id, SnapshotDetails]]] = [] # Use imported types

        # Initialize event queue (using Event from robot)
        self.priority_queue: List[Event] = []
        self.initialize_queue_exponential()

        self.current_time: Time = 0.0 # Use imported Time
        self.last_snapshot_time: Time = -1.0

        Scheduler._logger.info("--- Scheduler Initialized ---")

    # ... (rest of Scheduler methods remain the same, using imported types/constants)
    # Ensure SnapshotDetails, Event, RobotState, Coordinates etc. are used correctly

    def get_snapshot(self, time: Time) -> Dict[Id, SnapshotDetails]:
        """ Creates a snapshot of the current state of all robots. """
        snapshot: Dict[Id, SnapshotDetails] = {} # Hint using imported types
        for robot in self.robots:
            current_pos = robot.get_position(time) # Returns Coordinates
            # Use SnapshotDetails constructor from robot
            snapshot[robot.id] = SnapshotDetails(
                pos=current_pos,
                state=robot.state,
                frozen=robot.frozen,
                terminated=robot.terminated,
                multiplicity=1
            )

        if self.multiplicity_detection:
             self._detect_multiplicity(snapshot)

        return snapshot

    # ... other methods like _take_visualization_snapshot, generate_event, schedule_visualization_event ...
    # Ensure they use the imported Event, RobotState, Time, Id correctly.

    def generate_event(self, prev_event_time: Time, robot_id: Id, current_robot_state: str) -> None:
        # ... uses self.generator, self.lambda_rate ...
        robot = self.robots[robot_id]
        time_delta = self.generator.exponential(scale=1.0 / self.lambda_rate)
        new_activation_time = prev_event_time + max(time_delta, 1e-9)

        # Use RobotState constants from robot
        next_event_state = RobotState.LOOK
        if robot.state == RobotState.CRASH:
             next_event_state = RobotState.CRASH
        elif robot.terminated:
             Scheduler._logger.info(f"Robot R{robot_id} terminated. No new event scheduled.")
             return

        # Use Event constructor from robot
        priority_event = Event(new_activation_time, robot_id, next_event_state)
        heapq.heappush(self.priority_queue, priority_event)

    def schedule_visualization_event(self, current_time: Time):
         next_vis_time = current_time + self.sampling_rate
         # Use Event constructor from robot
         vis_event = Event(next_vis_time, -1, "VISUALIZE")
         heapq.heappush(self.priority_queue, vis_event)

    def handle_event(self) -> Tuple[int, Time, Union[Dict, None]]:
        # ... uses heapq, self.priority_queue, self.current_time ...
        # ... calls self._take_visualization_snapshot, self.schedule_visualization_event ...
        # ... uses RobotState constants ...
        # ... calls robot.look, robot.move, robot.wait, robot.set_faulty ...
        # ... calls self.generate_event, self._check_global_termination ...
        # ... returns Tuple[int, Time, Union[Dict, None]] ...

        if not self.priority_queue:
            Scheduler._logger.info("Event queue empty. Simulation likely ended.")
            self.terminate = True
            return (-1, self.current_time, None)

        current_event: Event = heapq.heappop(self.priority_queue) # Type hint Event
        time: Time = current_event.time
        robot_id: Id = current_event.id
        event_state: str = current_event.state

        if time < self.current_time:
             Scheduler._logger.warning(f"Time paradox! Event time {time:.4f} is before current time {self.current_time:.4f}. Skipping event: {current_event}")
             return (0, self.current_time, None)
        self.current_time = time

        if robot_id == -1 and event_state == "VISUALIZE":
            self._take_visualization_snapshot(time)
            self.schedule_visualization_event(time)
            latest_snapshot = self.visualization_snapshots[-1][1] if self.visualization_snapshots else None
            return (99, time, latest_snapshot)

        if robot_id < 0 or robot_id >= len(self.robots):
             Scheduler._logger.error(f"Invalid robot ID {robot_id} in event: {current_event}")
             return (0, time, None)

        robot = self.robots[robot_id]
        exit_code = 0

        # Use RobotState constants
        if robot.state == RobotState.CRASH and event_state != RobotState.CRASH:
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Ignoring event {event_state} because robot is CRASHED.")
             self.generate_event(time, robot_id, robot.state)
             return (0, time, None)
        if robot.terminated and event_state != RobotState.TERMINATED:
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Ignoring event {event_state} because robot is TERMINATED.")
             return (0, time, None)

        Scheduler._logger.info(f"--- T={time:.4f} Handling Event: R{robot_id} -> {event_state} ---")

        if event_state == RobotState.LOOK:
            current_snapshot = self.get_snapshot(time)
            robot.look(current_snapshot, time)

            if robot.state == RobotState.CRASH:
                 exit_code = 5
            elif robot.terminated:
                 exit_code = 4
            elif robot.frozen:
                 exit_code = 3
                 self.generate_event(time, robot_id, robot.state)
            else:
                 robot.move(time)
                 exit_code = 2
                 distance_to_target = 0.0
                 target_pos = robot.calculated_position
                 if target_pos:
                     distance_to_target = math.dist(robot.start_position, target_pos)
                 else:
                     Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Robot decided to move but has no target! Forcing WAIT.")
                     robot.wait(time)
                     exit_code = 3
                     self.generate_event(time, robot_id, robot.state)
                     return (exit_code, time, self.get_latest_snapshot())

                 move_duration = 0.0
                 if robot.speed > 1e-9:
                      # Assuming rigid movement for simplicity here based on previous version
                     move_duration = distance_to_target / robot.speed
                     if move_duration == 0 :
                          Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Zero move duration calculated but robot was not frozen. dist={distance_to_target}")

                 move_duration = max(0, move_duration)
                 wait_event_time = time + move_duration
                 # Use Event constructor
                 wait_event = Event(wait_event_time, robot_id, RobotState.WAIT)
                 heapq.heappush(self.priority_queue, wait_event)
                 Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Scheduled WAIT event at T={wait_event_time:.4f} (duration {move_duration:.4f})")

        elif event_state == RobotState.WAIT:
             robot.wait(time)
             exit_code = 3
             self.generate_event(time, robot_id, robot.state)

        elif event_state == RobotState.MOVE:
             Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Received unexpected MOVE event. State: {robot.state}. Ignoring.")
             exit_code = 0

        elif event_state == RobotState.CRASH:
             robot.set_faulty(True)
             exit_code = 5
             Scheduler._logger.info(f"T={time:.4f} R{robot_id}: Marked as CRASHED by event.")

        else:
             Scheduler._logger.warning(f"T={time:.4f} R{robot_id}: Unhandled event state '{event_state}'")
             exit_code = 0

        if self._check_global_termination():
             Scheduler._logger.info(f"--- T={time:.4f} Global Termination Condition Met ---")
             self.terminate = True
             return (-1, time, self.get_snapshot(time))

        latest_snapshot = self.visualization_snapshots[-1][1] if self.visualization_snapshots else self.get_snapshot(time)
        return (exit_code, time, latest_snapshot)


    def initialize_queue_exponential(self) -> None:
        # ... uses self.generator, self.lambda_rate, self.robots ...
        # ... uses RobotState, Event, Time, Id ...
        Scheduler._logger.info("Initializing event queue with exponential distribution...")
        initial_times = self.generator.exponential(scale=1.0 / self.lambda_rate, size=len(self.robots))
        self.priority_queue = []
        for i, robot in enumerate(self.robots):
             initial_state = RobotState.LOOK
             if robot.state == RobotState.CRASH:
                  initial_state = RobotState.CRASH
             event_time = max(0, initial_times[i])
             # Use Event constructor
             event = Event(event_time, robot.id, initial_state)
             self.priority_queue.append(event)
             Scheduler._logger.info(f"  Initial event for R{robot.id}: {initial_state} at T={event_time:.4f}")

        self.schedule_visualization_event(0.0)
        heapq.heapify(self.priority_queue)
        Scheduler._logger.info("Event queue initialized.")


    def _check_global_termination(self) -> bool:
        # ... uses self.robots, RobotState ...
        num_non_crashed = 0
        all_terminated = True
        for robot in self.robots:
            if robot.state != RobotState.CRASH:
                num_non_crashed += 1
                if not robot.terminated:
                    all_terminated = False
                    break # No need to check further

        if num_non_crashed == 0 and len(self.robots) > 0:
             Scheduler._logger.info("Global termination: All robots have crashed.")
             return True
        if num_non_crashed > 0 and all_terminated:
             Scheduler._logger.info("Global termination: All non-crashed robots are terminated.")
             return True

        return False

    def _detect_multiplicity(self, snapshot: Dict[Id, SnapshotDetails]):
        # ... uses SnapshotDetails, Coordinates, Id, math.dist, round_coordinates ...
        positions_list: List[Tuple[Coordinates, Id]] = []
        for robot_id, details in snapshot.items():
             if details.pos:
                positions_list.append((details.pos, robot_id))

        positions_list.sort(key=lambda item: (item[0].x, item[0].y)) # Access .x, .y

        n = len(positions_list)
        visited = [False] * n
        multiplicity_groups: List[List[Id]] = []

        for i in range(n):
            if visited[i]: continue
            current_group = [positions_list[i][1]]
            visited[i] = True
            # pos1_rounded = round_coordinates(positions_list[i][0], self.threshold_precision) # Can use rounding or dist

            for j in range(i + 1, n):
                if visited[j]: continue
                # pos2_rounded = round_coordinates(positions_list[j][0], self.threshold_precision)
                # if pos1_rounded == pos2_rounded:

                # Use distance check which might be more robust
                distance = math.dist(positions_list[i][0], positions_list[j][0])
                if distance < math.pow(10, -self.threshold_precision):
                    visited[j] = True
                    current_group.append(positions_list[j][1])

            if len(current_group) > 0:
                multiplicity_groups.append(current_group)

        for group in multiplicity_groups:
            count = len(group)
            if count > 1:
                for robot_id in group:
                    details = snapshot[robot_id]
                    # Use _replace for NamedTuple update
                    snapshot[robot_id] = details._replace(multiplicity=count)


    def get_latest_snapshot(self) -> Union[Dict[Id, SnapshotDetails], None]:
        if self.visualization_snapshots:
            return self.visualization_snapshots[-1][1]
        else:
            return self.get_snapshot(self.current_time)


    def get_all_robot_data_for_js(self) -> List[Dict]:
        # ... uses self.robots, RobotState, Coordinates, Circle ...
        robot_data = []
        latest_snap = self.get_latest_snapshot() # Get snapshot once for multiplicity

        for robot in self.robots:
             pos = robot.get_position(self.current_time) # Returns Coordinates
             multiplicity = 1 # Default
             if latest_snap and robot.id in latest_snap:
                 multiplicity = latest_snap[robot.id].multiplicity or 1

             # Prepare SEC data if available
             sec_data = None
             if robot.sec: # Check if robot.sec (Circle) exists
                  # Access .center.x, .center.y, .radius
                 sec_data = {"center_x": robot.sec.center.x, "center_y": robot.sec.center.y, "radius": robot.sec.radius}

             # Prepare target data if available
             target_x = None
             target_y = None
             if robot.calculated_position: # Check if Coordinates object exists
                 target_x = robot.calculated_position.x
                 target_y = robot.calculated_position.y

             robot_data.append({
                 "id": robot.id,
                 "x": pos.x, # Access .x
                 "y": pos.y, # Access .y
                 "state": robot.state,
                 "frozen": robot.frozen,
                 "terminated": robot.terminated,
                 "crashed": robot.state == RobotState.CRASH,
                 "multiplicity": multiplicity, # Get from snapshot lookup
                 "sec": sec_data,
                 "target_x": target_x,
                 "target_y": target_y,
                 "speed": robot.speed,
                 "visibility_radius": robot.visibility_radius if robot.visibility_radius != float('inf') else None
             })

        return robot_data